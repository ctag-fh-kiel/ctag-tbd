#include <atomic>
#include "ctagSoundProcessor.hpp"
#include "helpers/ctagADEnv.hpp"            // Needed for AD EG (Attack/Decay Envelope Generator)
#include "helpers/ctagADSREnv.hpp"          // Needed for ADSR EG (Attack/Decay/Sustain/Release Envelope Generator)


// --- VULT "Library for TBD" ---
#include "./vult/vult_formantor.h"
#include "./vult/vult_formantor.tables.h"

using namespace CTAG::SP::HELPERS;

namespace CTAG {
    namespace SP {
        class ctagSoundProcessorFormantor : public ctagSoundProcessor {
        public:
            virtual void Process(const ProcessData &) override;
            ctagSoundProcessorFormantor();
            virtual ~ctagSoundProcessorFormantor();

        private:
            virtual void knowYourself() override;

            // --- Vowel/formant filter ---
            int i_FormantSelect_save = 0;         // This is a buffer variable in case we allow switching of formants only on note-change

            // --- Keyboard logic[s] to switch formants ---
            int formant_trigger[12] = {-1,0,-1,1,-1,-1,2,-1,3,-1,4,-1};   // Black keys on a keyboard
            int formant_selected = 0;   // We remember the most recent trigger-key of the formant here
            int i_note_save = 36;          // We remember the last note, in case we select formants via black keys...
            float f_note_save = 36.f;      // We remember the last note, in case we select formants via black keys...

            // --- Remember status of triggers / buttons ---
            inline int process_param_trig( const ProcessData &data, int trig_myparm, int my_parm, int prev_trig_state_id ); // rescale incoming data to bool
            enum trig_states
            {
                e_Gate, e_EGvolActive, e_EGvolSlow, e_FormantBlendingOn, e_FormantFilterOn, e_BlackKeyLogic, e_FormantLock, e_ADSRon, e_Formantor_options_max
            };
            int prev_trig_state[e_Formantor_options_max] = {-1};   // Initialize _all_ entries with "low value" // ### check for bugs!

            // --- VULT Stuff ---
            Phasedist_real_process_type pd_data;        // VULT PD synth voice internal datastructure, also needed for initialisation
            Svf__ctx_type_4 svf_data_x;                 // State Variable Filter (Bandpass) init (svf_data_x,y,z... for 3 bandpasses);
            Svf__ctx_type_4 svf_data_y;
            Svf__ctx_type_4 svf_data_z;

            // --- Volume EG --
            ctagADEnv vol_eg_ad;
            ctagADSREnv vol_eg_adsr;

            // private attributes could go here
            // autogenerated code here
            // sectionHpp
	atomic<int32_t> Gate, trig_Gate;
	atomic<int32_t> MasterPitch, cv_MasterPitch;
	atomic<int32_t> Volume, cv_Volume;
	atomic<int32_t> PDamount, cv_PDamount;
	atomic<int32_t> FormantFilterOn, trig_FormantFilterOn;
	atomic<int32_t> BlackKeyLogic, trig_BlackKeyLogic;
	atomic<int32_t> FormantLock, trig_FormantLock;
	atomic<int32_t> FormantSelect, cv_FormantSelect;
	atomic<int32_t> CutOffX_1, cv_CutOffX_1;
	atomic<int32_t> ResoX_1, cv_ResoX_1;
	atomic<int32_t> FltAmntX_1, cv_FltAmntX_1;
	atomic<int32_t> CutOffY_1, cv_CutOffY_1;
	atomic<int32_t> ResoY_1, cv_ResoY_1;
	atomic<int32_t> FltAmntY_1, cv_FltAmntY_1;
	atomic<int32_t> CutOffZ_1, cv_CutOffZ_1;
	atomic<int32_t> ResoZ_1, cv_ResoZ_1;
	atomic<int32_t> FltAmntZ_1, cv_FltAmntZ_1;
	atomic<int32_t> BPamnt_1, cv_BPamnt_1;
	atomic<int32_t> CutOffX_2, cv_CutOffX_2;
	atomic<int32_t> ResoX_2, cv_ResoX_2;
	atomic<int32_t> FltAmntX_2, cv_FltAmntX_2;
	atomic<int32_t> CutOffY_2, cv_CutOffY_2;
	atomic<int32_t> ResoY_2, cv_ResoY_2;
	atomic<int32_t> FltAmntY_2, cv_FltAmntY_2;
	atomic<int32_t> CutOffZ_2, cv_CutOffZ_2;
	atomic<int32_t> ResoZ_2, cv_ResoZ_2;
	atomic<int32_t> FltAmntZ_2, cv_FltAmntZ_2;
	atomic<int32_t> BPamnt_2, cv_BPamnt_2;
	atomic<int32_t> CutOffX_3, cv_CutOffX_3;
	atomic<int32_t> ResoX_3, cv_ResoX_3;
	atomic<int32_t> FltAmntX_3, cv_FltAmntX_3;
	atomic<int32_t> CutOffY_3, cv_CutOffY_3;
	atomic<int32_t> ResoY_3, cv_ResoY_3;
	atomic<int32_t> FltAmntY_3, cv_FltAmntY_3;
	atomic<int32_t> CutOffZ_3, cv_CutOffZ_3;
	atomic<int32_t> ResoZ_3, cv_ResoZ_3;
	atomic<int32_t> FltAmntZ_3, cv_FltAmntZ_3;
	atomic<int32_t> BPamnt_3, cv_BPamnt_3;
	atomic<int32_t> CutOffX_4, cv_CutOffX_4;
	atomic<int32_t> ResoX_4, cv_ResoX_4;
	atomic<int32_t> FltAmntX_4, cv_FltAmntX_4;
	atomic<int32_t> CutOffY_4, cv_CutOffY_4;
	atomic<int32_t> ResoY_4, cv_ResoY_4;
	atomic<int32_t> FltAmntY_4, cv_FltAmntY_4;
	atomic<int32_t> CutOffZ_4, cv_CutOffZ_4;
	atomic<int32_t> ResoZ_4, cv_ResoZ_4;
	atomic<int32_t> FltAmntZ_4, cv_FltAmntZ_4;
	atomic<int32_t> BPamnt_4, cv_BPamnt_4;
	atomic<int32_t> CutOffX_5, cv_CutOffX_5;
	atomic<int32_t> ResoX_5, cv_ResoX_5;
	atomic<int32_t> FltAmntX_5, cv_FltAmntX_5;
	atomic<int32_t> CutOffY_5, cv_CutOffY_5;
	atomic<int32_t> ResoY_5, cv_ResoY_5;
	atomic<int32_t> FltAmntY_5, cv_FltAmntY_5;
	atomic<int32_t> CutOffZ_5, cv_CutOffZ_5;
	atomic<int32_t> ResoZ_5, cv_ResoZ_5;
	atomic<int32_t> FltAmntZ_5, cv_FltAmntZ_5;
	atomic<int32_t> BPamnt_5, cv_BPamnt_5;
	atomic<int32_t> TremoloActive, trig_TremoloActive;
	atomic<int32_t> TremoloAfterFormant, trig_TremoloAfterFormant;
	atomic<int32_t> TremoloAttack, cv_TremoloAttack;
	atomic<int32_t> TremoloSpeed, cv_TremoloSpeed;
	atomic<int32_t> TremoloAmount, cv_TremoloAmount;
	atomic<int32_t> EGvolActive, trig_EGvolActive;
	atomic<int32_t> EGvolSlow, trig_EGvolSlow;
	atomic<int32_t> Attack, cv_Attack;
	atomic<int32_t> Decay, cv_Decay;
	atomic<int32_t> ADSRon, trig_ADSRon;
	atomic<int32_t> Sustain, cv_Sustain;
	atomic<int32_t> Release, cv_Release;
	// sectionHpp
        };
    }
}