#include "ctagSoundProcessorClap.hpp"

using namespace CTAG::SP;

void ctagSoundProcessorClap::Process(const ProcessData &data) {
    MK_FLT_PAR_ABS_MIN_MAX(fTone1, tone, 4095.f, 400.f, 4000.f)
    MK_FLT_PAR_ABS_MIN_MAX(fReso1, t_p1, 4095.f, 1.f, 2.5f)
    svf1.set_f_q<stmlib::FREQUENCY_DIRTY>(fTone1/44100.f, fReso1);
    MK_FLT_PAR_ABS_MIN_MAX(fTone2, tone, 4095.f, 400.f, 2200.f)
    MK_FLT_PAR_ABS_MIN_MAX(fReso2, t_p1, 4095.f, 0.75f, 6.5f)
    svf2.set_f_q<stmlib::FREQUENCY_DIRTY>(fTone2/44100.f, fReso2);
    MK_FLT_PAR_ABS_MIN_MAX(fDecay1, decay, 4095.f, 0.2f, 0.3f)
    MK_FLT_PAR_ABS_MIN_MAX(fDecay2, decay, 4095.f, 0.2f, 2.f)
    env1.SetDecay(fDecay1);
    env2.SetDecay(fDecay2);
    MK_FLT_PAR_ABS_MIN_MAX(fAttack2, t_p2, 4095.f, 0.f, 0.2f)
    MK_FLT_PAR_ABS_MIN_MAX(fScale, t_p2, 4095.f, 1.f, 4.f)
    env2.SetAttack(fAttack2);
    iTransient = t_p3;
    if(cv_t_p3 != -1) iTransient = static_cast<int>(fabsf(data.cv[cv_t_p3]) * 8);
    CONSTRAIN(iTransient, 0, 7)
    MK_BOOL_PAR(isTrig, trg);
    // trigger env1 if isTrig had rising edge
    if(isTrig == true && isTrig != previous_trigger){
        env1.Trigger();
        timers[0].SetTimeout(delays[iTransient][0] * fScale);
        timers[1].SetTimeout(delays[iTransient][1] * fScale);
        timers[2].SetTimeout(delays[iTransient][2] * fScale);
        timers[3].SetTimeout(delays[iTransient][3] * fScale);
        previous_trigger = true;
    }else if(isTrig == false){
        previous_trigger = false;
    }
    for(int i=0;i<32;i++){
        timers[0].Tick();
        timers[1].Tick();
        timers[2].Tick();
        timers[3].Tick();
        float noise = stmlib::Random::GetFloat();
        noise = noise > 0.5f ? 1.f : -1.f;
        float transient = svf1.Process<stmlib::FILTER_MODE_BAND_PASS>(noise);
        transient *= env1.Process() * a1;
        float tail = svf2.Process<stmlib::FILTER_MODE_BAND_PASS>(noise);
        tail *= env2.Process() * a2;
        data.buf[i*2 + 0] = transient + tail;
        data.buf[i*2 + 1] = transient + tail;
    }

}

void ctagSoundProcessorClap::Init(std::size_t blockSize, void *blockPtr) {
    // construct internal data model
    knowYourself();
    model = std::make_unique<ctagSPDataModel>(id, isStereo);
    LoadPreset(0);

    // check if blockMem is large enough
    // blockMem is used just like larger blocks of heap memory
    // assert(blockSize >= memLen);
    // if memory larger than blockMem is needed, use heap_caps_malloc() instead with MALLOC_CAPS_SPIRAM

    svf1.Init();
    svf2.Init();
    stmlib::Random::Seed(42);
    env1.SetSampleRate(44100.f);
    env1.SetModeExp();
    env1.SetAttack(0.f);
    env1.SetLoop(false);
    env2.SetSampleRate(44100.f);
    env2.SetModeExp();
    env2.SetAttack(0.f);
    env2.SetLoop(false);

    timers[0].SetTimeoutCallback([&](){a1 = amplitudes[iTransient][0]; env1.Trigger();});
    timers[1].SetTimeoutCallback([&](){a1 = amplitudes[iTransient][1]; env1.Trigger();});
    timers[2].SetTimeoutCallback([&](){a1 = amplitudes[iTransient][2]; env1.Trigger();});
    timers[3].SetTimeoutCallback([&](){a2 = amplitudes[iTransient][3]; env2.Trigger();});
}

// no ctor, use Init() instead, is called from factory after successful creation
// dtor
ctagSoundProcessorClap::~ctagSoundProcessorClap() {
    // no explicit freeing for blockMem needed, done by ctagSPAllocator
    // explicit free is only needed when using heap_caps_malloc() with MALLOC_CAPS_SPIRAM
}

void ctagSoundProcessorClap::knowYourself(){
    // autogenerated code here
    // sectionCpp0
	pMapPar.emplace("trg", [&](const int val){ trg = val;});
	pMapTrig.emplace("trg", [&](const int val){ trig_trg = val;});
	pMapPar.emplace("decay", [&](const int val){ decay = val;});
	pMapCv.emplace("decay", [&](const int val){ cv_decay = val;});
	pMapPar.emplace("tone", [&](const int val){ tone = val;});
	pMapCv.emplace("tone", [&](const int val){ cv_tone = val;});
	pMapPar.emplace("t_p1", [&](const int val){ t_p1 = val;});
	pMapCv.emplace("t_p1", [&](const int val){ cv_t_p1 = val;});
	pMapPar.emplace("t_p2", [&](const int val){ t_p2 = val;});
	pMapCv.emplace("t_p2", [&](const int val){ cv_t_p2 = val;});
	pMapPar.emplace("t_p3", [&](const int val){ t_p3 = val;});
	pMapCv.emplace("t_p3", [&](const int val){ cv_t_p3 = val;});
	isStereo = false;
	id = "Clap";
	// sectionCpp0
}