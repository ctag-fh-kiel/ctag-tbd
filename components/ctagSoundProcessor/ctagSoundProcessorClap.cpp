#include "ctagSoundProcessorClap.hpp"
#include "stmlib/dsp/dsp.h"
#include "helpers/ctagFastMath.hpp"

using namespace CTAG::SP;

inline float DistortedSine(float phase) {

    float triangle = (phase < 0.5f ? phase : 1.0f - phase) * 4.0f - 1.3f;
    return 2.0f * triangle / (1.0f + fabsf(triangle));

    //return phase < 0.5f ? 1.f : -1.f;
    return sinf(phase * 2.f * M_PI);
}

void ctagSoundProcessorClap::Process(const ProcessData &data) {
    MK_FLT_PAR_ABS_MIN_MAX(fTone1, tone, 4095.f, 100.f/44100.f, 750.f/44100.f)
    MK_FLT_PAR_ABS_MIN_MAX(fDecay1, decay, 4095.f, 1.f, 100.f)
    MK_FLT_PAR_ABS_MIN_MAX(fScale, t_p1, 4095.f, fTone1/2.f, fTone1*8.f)
    MK_FLT_PAR_ABS_MIN_MAX(fFilterQ, t_p2, 4095.f, 1.f, 20.f)
    MK_FLT_PAR_ABS_MIN_MAX(fDist, t_p3, 4095.f, 1.f, 1000.f)
    MK_BOOL_PAR(isTrig, trg);
    // trigger env1 if isTrig had rising edge
    if(isTrig == true && isTrig != previous_trigger){
        env[0].Trigger();
        env[1].Trigger();
        env[2].Trigger();
        phase[0] = 0.f;
        phase[1] = 0.f;
        phase[2] = 0.f;
        dcy[0] = 1.f;
        dcy[1] = 1.f;
        dcy[2] = 1.f;
        previous_trigger = true;
    }else if(isTrig == false){
        previous_trigger = false;
    }
    env[0].SetDecay(0.010f);
    env[1].SetDecay(0.020f*fDecay1);
    env[2].SetDecay(0.05f);
    svf.set_f_q<stmlib::FREQUENCY_DIRTY>(fScale, fFilterQ);
    float phaseinc1 = fTone1;
    float phaseinc2 = fTone1 * 2.f;
    float phaseinc3 = fTone1 * 4.f;
    for(int i=0;i<32;i++){
        phase[0] += phaseinc1;
        phase[1] += phaseinc2;
        phase[2] += phaseinc3;
        if(phase[0] > 1.f) phase[0] -= 1.f;
        if(phase[1] > 1.f) phase[1] -= 1.f;
        if(phase[2] > 1.f) phase[2] -= 1.f;
        float s1, s2, s3;
        s1 = DistortedSine(phase[0]) * env[0].Process();
        s2 = DistortedSine(phase[1]) * env[1].Process();
        s3 = DistortedSine(phase[2]) * env[2].Process();
        float sum = s1 + s2 * 0.5f + s3;
        sum = HELPERS::fasttanh(sum * fDist);
        sum = svf.Process<stmlib::FILTER_MODE_HIGH_PASS>(sum);
        data.buf[i*2 + 0] = sum;
        data.buf[i*2 + 1] = data.buf[i*2 + 0];
    }

}

void ctagSoundProcessorClap::Init(std::size_t blockSize, void *blockPtr) {
    // construct internal data model
    knowYourself();
    model = std::make_unique<ctagSPDataModel>(id, isStereo);
    LoadPreset(0);

    // check if blockMem is large enough
    // blockMem is used just like larger blocks of heap memory
    // assert(blockSize >= memLen);
    // if memory larger than blockMem is needed, use heap_caps_malloc() instead with MALLOC_CAPS_SPIRAM
    env[0].SetAttack(0.f);
    env[0].SetModeExp();
    env[0].SetSampleRate(44100.f);
    // do same for other envs
    env[1].SetAttack(0.f);
    env[1].SetModeExp();
    env[1].SetSampleRate(44100.f);
    env[2].SetAttack(0.f);
    env[2].SetModeExp();
    env[2].SetSampleRate(44100.f);

    svf.Init();
}

// no ctor, use Init() instead, is called from factory after successful creation
// dtor
ctagSoundProcessorClap::~ctagSoundProcessorClap() {
    // no explicit freeing for blockMem needed, done by ctagSPAllocator
    // explicit free is only needed when using heap_caps_malloc() with MALLOC_CAPS_SPIRAM
}

void ctagSoundProcessorClap::knowYourself(){
    // autogenerated code here
    // sectionCpp0
	pMapPar.emplace("trg", [&](const int val){ trg = val;});
	pMapTrig.emplace("trg", [&](const int val){ trig_trg = val;});
	pMapPar.emplace("decay", [&](const int val){ decay = val;});
	pMapCv.emplace("decay", [&](const int val){ cv_decay = val;});
	pMapPar.emplace("tone", [&](const int val){ tone = val;});
	pMapCv.emplace("tone", [&](const int val){ cv_tone = val;});
	pMapPar.emplace("t_p1", [&](const int val){ t_p1 = val;});
	pMapCv.emplace("t_p1", [&](const int val){ cv_t_p1 = val;});
	pMapPar.emplace("t_p2", [&](const int val){ t_p2 = val;});
	pMapCv.emplace("t_p2", [&](const int val){ cv_t_p2 = val;});
	pMapPar.emplace("t_p3", [&](const int val){ t_p3 = val;});
	pMapCv.emplace("t_p3", [&](const int val){ cv_t_p3 = val;});
	isStereo = false;
	id = "Clap";
	// sectionCpp0
}