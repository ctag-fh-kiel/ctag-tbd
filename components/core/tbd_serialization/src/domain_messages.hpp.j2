#pragma once

#include <tbd/serialization/message_transcoding.hpp>

{% for cls_header in cls_headers -%}
#include <{{ cls_header }}>
{% endfor %}
#include <tbd/errors.hpp>


//// anonymous class DTOs ////
{% if anonymous_dtos -%}
{%- for anon_dto in anonymous_dtos -%}
{%- set full_name = anon_dto.full_name %}
// {{ full_name }}

namespace {{ anon_dto.scope.parent }} { struct {{ anon_dto.cls_name }} {
    {% for prop in anon_dto.properties -%}
    {{ prop.typename }} {{ prop.field_name }};
    {% endfor %}
}; }

namespace tbd::serialization {
template<>
struct SerializableImpl<{{ full_name }}> {
    SerializableImpl() = delete;

    static size_t serialized_size(const {{ full_name }}& obj);
    static constexpr TypeID type_id() { return {{ anon_dto.ref() }}; }
    static constexpr bool is_directly_serializable() { return true; };

    static Error read_serializable(std::istream& in_stream, {{ full_name }}& in_message);
    static Error write_serializable(std::ostream& out_stream, const {{ full_name }}& out_message);
    static Error to_dto(const {{ full_name }}& obj, {{ full_name }}& dto);
    static Error from_dto(const {{ full_name }}& dto, {{ full_name }}& obj);
};
{%  if anon_dto.properties %}
inline size_t SerializableImpl<{{ full_name }}>::serialized_size(const {{ full_name }}& obj) {
    return {% for path, property in anon_dto | flattened_properties -%}
    {{ '+'  if not loop.first }} sizeof({{ property.type }}){{ ';' if loop.last }}
    {% endfor %}
}
{%- else -%}
inline size_t SerializableImpl<{{ full_name }}>::serialized_size(const {{ full_name }}& obj) { return 0; }
{%  endif %}
}
{% endfor -%}
{%- endif %}


namespace tbd::serialization {

//// directly serializable types ////
{% if serializables -%}
{%- for serializable in serializables -%}
{%- set full_name = serializable.full_name %}
template<>
struct SerializableImpl<{{ full_name }}> {
    SerializableImpl() = delete;

    static size_t serialized_size(const {{ full_name }}& obj);
    static constexpr TypeID type_id() { return {{ serializable.ref() }}; }
    static constexpr bool is_directly_serializable() { return true; };

    static Error read_serializable(std::istream& in_stream, {{ full_name }}& in_message);
    static Error write_serializable(std::ostream& out_stream, const {{ full_name }}& out_message);
    static Error to_dto(const {{ full_name }}& obj, {{ full_name }}& dto);
    static Error from_dto(const {{ full_name }}& dto, {{ full_name }}& obj);
};
{% endfor -%}
{%- endif %}

{% for serializable in serializables %}
{%- set full_name = serializable.full_name -%}

{%  if serializable.properties %}
inline size_t SerializableImpl<{{ full_name }}>::serialized_size(const {{ full_name }}& obj) {
    return {% for path, property in serializable | flattened_properties -%}
    {{ '+'  if not loop.first }} sizeof({{ property.type }}){{ ';' if loop.last }}
    {% endfor %}
}
{%- else -%}
inline size_t SerializableImpl<{{ full_name }}>::serialized_size(const {{ full_name }}& obj) { return 0; }
{%  endif %}
{% endfor %}
}

//// types with associated DTOs ////
{% for cls, cls_dto in class_dtos %}
{%- set full_cls_name = cls.full_name -%}
{%- set full_dto_name = cls_dto.full_name -%}

// {{ full_cls_name }}

namespace {{ cls_dto.scope.parent }} { struct {{ cls_dto.cls_name }} {
    {% for prop in cls_dto.properties -%}
    {{ prop.typename }} {{ prop.field_name }};
    {% endfor %}
}; }

namespace tbd::serialization {

template<>
struct SerializableImpl<{{ full_dto_name }}> {
    SerializableImpl() = delete;

    static size_t serialized_size(const {{ full_dto_name }}& obj);
    static constexpr TypeID type_id() { return {{ cls_dto.ref() }}; }
    static constexpr bool is_directly_serializable() { return true; };

    static Error read_serializable(std::istream& in_stream, {{ full_dto_name }}& in_message);
    static Error write_serializable(std::ostream& out_stream, const {{ full_dto_name }}& out_message);
    static Error to_dto(const {{ full_dto_name }}& obj, {{ full_dto_name }}& cls_dto);
    static Error from_dto(const {{ full_dto_name }}& cls_dto, {{ full_dto_name }}& obj);
};

{%  if cls_dto.properties %}
inline size_t SerializableImpl<{{ full_dto_name }}>::serialized_size(const {{ full_dto_name }}& obj) {
    return {% for path, property in cls_dto | flattened_properties -%}
    {{ '+'  if not loop.first }} sizeof({{ property.type }}){{ ';' if loop.last }}
    {% endfor %}
}
{%- else -%}
inline size_t SerializableImpl<{{ full_dto_name }}>::serialized_size(const {{ full_dto_name }}& obj) { return 0; }
{%  endif %}

template<>
struct SerializableImpl<{{ full_cls_name }}> {
    SerializableImpl() = delete;

    static size_t serialized_size(const {{ full_cls_name }}& obj);
    static constexpr TypeID type_id() { return {{ cls_dto.ref() }}; }
    static constexpr bool is_directly_serializable() { return false; };

    static Error read_serializable(std::istream& in_stream, {{ full_cls_name }}& obj);
    static Error write_serializable(std::ostream& out_stream, const {{ full_cls_name }}& obj);
    static Error to_dto(const {{ full_cls_name }}& obj, {{ full_dto_name }}& cls_dto);
    static Error from_dto(const {{ full_dto_name }}& cls_dto, {{ full_cls_name }}& obj);
};

}
{% endfor %}

//// generated DTO types ////
{% if dtos -%}
{%- for dto in dtos -%}
{%- set full_name = dto.full_name %}
// {{ full_name }}

namespace {{ dto.scope.parent }} { struct {{ dto.cls_name }} {
    {% for prop in dto.properties -%}
    {{ prop.typename }} {{ prop.field_name }};
    {% endfor %}
}; }

namespace tbd::serialization {
template<>
struct SerializableImpl<{{ full_name }}> {
    SerializableImpl() = delete;

    static size_t serialized_size(const {{ full_name }}& obj);
    static constexpr TypeID type_id() { return {{ dto.ref() }}; }
    static constexpr bool is_directly_serializable() { return true; };

    static Error read_serializable(std::istream& in_stream, {{ full_name }}& in_message);
    static Error write_serializable(std::ostream& out_stream, const {{ full_name }}& out_message);
    static Error to_dto(const {{ full_name }}& obj, {{ full_name }}& dto);
    static Error from_dto(const {{ full_name }}& dto, {{ full_name }}& obj);
};
{%  if dto.properties %}
inline size_t SerializableImpl<{{ full_name }}>::serialized_size(const {{ full_name }}& obj) {
    return {% for path, property in dto | flattened_properties -%}
    {{ '+'  if not loop.first }} sizeof({{ property.type }}){{ ';' if loop.last }}
    {% endfor %}
}
{%- else -%}
inline size_t SerializableImpl<{{ full_name }}>::serialized_size(const {{ full_name }}& obj) { return 0; }
{%  endif %}
}
{% endfor -%}
{%- endif %}
