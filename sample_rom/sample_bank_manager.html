<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sample Bank Builder (128)</title>
  <style>
    :root { --b:#e5e7eb; --t:#111827; --muted:#6b7280; --pri:#334155; --acc:#1d4ed8; }
    * { box-sizing: border-box; }
    body { margin: 0; font: 14px/1.4 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color: var(--t); }
    header, section { padding: 12px 16px; }
    header { position: sticky; top: 0; background: #fff; border-bottom: 1px solid var(--b); z-index: 10; }
    h1 { font-size: 16px; margin: 0 0 8px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    button { padding: 6px 10px; border: 1px solid var(--b); background: #fff; border-radius: 6px; cursor: pointer; }
    button:disabled { opacity: .5; cursor: default; }
    .pill { background: #eef; border: 1px solid #cfe; border-radius: 999px; padding: 2px 8px; font-size: 12px; }
    .muted { color: var(--muted); }
    #browser { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    #fileList, #bankList { border: 1px solid var(--b); border-radius: 6px; overflow: auto; height: 360px; padding: 6px; }
    .item { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; padding: 6px 4px; border-bottom: 1px dotted var(--b); }
    .item:last-child { border-bottom: 0; }
    .name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .meta { font-size: 12px; color: var(--muted); }
    #preview { border-top: 1px solid var(--b); padding-top: 12px; }
    #waveform { height: 120px; border: 1px solid var(--b); border-radius: 6px; }
  #lowResRow { margin-top: 8px; }
  #lowResLabel { font-weight: 600; margin-right: 8px; }
  #lowResPreview {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    image-rendering: -moz-crisp-edges;
    background: #000;
    /* Size controlled by JavaScript slider for accurate physical dimension calibration */
  }
  #oledContainer {
    display: inline-block;
    position: relative;
  }
  #oledFrame {
    background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
    border-radius: 8px;
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
    position: relative;
  }
  #oledActiveArea {
    position: absolute;
    background: #000;
    pointer-events: none;
  }
  #oledScaler {
    transform-origin: top left;
    transition: transform 0.2s ease;
    position: relative;
  }
  .zoom-controls {
    display: inline-flex;
    gap: 4px;
    margin-left: 12px;
  }
  .zoom-btn {
    padding: 4px 8px;
    font-size: 11px;
    min-width: 40px;
  }
  .display-info {
    font-size: 11px;
    color: var(--muted);
    margin-left: 12px;
  }
  .size-calibration {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    padding: 8px;
    background: #f9fafb;
    border-radius: 4px;
    border: 1px solid var(--b);
  }
  .size-slider {
    width: 200px;
  }
    #warnings { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; background: #fff7ed; border: 1px solid #fed7aa; color: #9a3412; border-radius: 6px; padding: 8px; display: none; }
    .folder { margin: 4px 0; }
    .folder > summary { cursor: pointer; font-weight: 600; }
    .leaf { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; padding: 4px 2px; border-bottom: 1px dotted var(--b); }
    .leaf .name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .leaf .meta { font-size: 12px; color: var(--muted); }
    .right-actions .btn { margin-left: 6px; }
    .capacity { font-size: 12px; color: var(--muted); }
    .cap-ok { color: #065f46; }
    .cap-warn { color: #92400e; }
    .cap-err { color: #991b1b; }
    .toggle-on { background: #e0f2fe; border-color: #7dd3fc; }
    .toggle-off { background: #f3f4f6; border-color: #d1d5db; }
    .slot-badge { display: inline-block; min-width: 1.8em; text-align: right; margin-right: 8px; color: #374151; font-weight: 600; }
    .drop-target { outline: 2px dashed #60a5fa; outline-offset: 2px; }
  </style>
</head>
<body>
  <header>
    <h1>Sample Bank Builder (128)</h1>
    <div class="row">
      <input id="dirInput" type="file" webkitdirectory multiple hidden />
      <button id="pickBtn">Pick tbdsamples folder‚Ä¶</button>
      <span id="summary" class="muted">No folder loaded</span>
      <span id="counter" class="pill">0/128 selected</span>
      <button id="enableAudioBtn" title="Click once if your browser blocks autoplay">Enable audio</button>
    </div>
  </header>

  <section id="browser">
    <div>
      <div class="row" style="margin-bottom:6px; justify-content: space-between;">
        <strong>Converted files</strong>
        <span class="muted">Hover to preview ‚Ä¢ Click Add to select</span>
      </div>
      <div id="fileList"></div>
    </div>
    <div>
      <div class="row" style="margin-bottom:6px; justify-content: space-between; align-items: baseline;">
        <strong>Selected bank</strong>
        <div class="row">
          <span id="capacityInfo" class="capacity"></span>
          <input id="loadInput" type="file" accept=".jsn" hidden />
          <button id="loadBtn" disabled>Load JSN</button>
          <button id="clearBtn" disabled>Clear</button>
          <button id="exportBtn" disabled>Export JSN</button>
          <button id="saveToFolderBtn" disabled>Save to folder</button>
        </div>
      </div>
      <div id="bankList"></div>
    </div>
  </section>

  <section id="preview">
    <div class="row" style="justify-content: space-between;">
      <div class="row">
        <strong>Preview:</strong>
        <span id="currentName" class="muted">Nothing selected</span>
        <span id="duration" class="pill">--:--</span>
      </div>
    </div>
    <div id="waveform"></div>
      <div id="lowResRow">
      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; flex-wrap: wrap;">
        <span id="lowResLabel">2.42" OLED Preview (128√ó64 monochrome):</span>
        <span id="analysisInfo" class="pill" style="font-size: 11px;"></span>
        <div class="zoom-controls">
          <button id="zoom1x" class="zoom-btn">1√ó</button>
          <button id="zoom2x" class="zoom-btn">2√ó</button>
          <button id="zoom3x" class="zoom-btn">3√ó</button>
          <button id="zoom4x" class="zoom-btn">4√ó</button>
        </div>
        <span class="display-info">Click waveform to seek ‚Ä¢ Space=Play/Pause</span>
      </div>
      <div class="size-calibration">
        <label for="sizeSlider" style="font-weight: 600; white-space: nowrap;">Physical Size:</label>
        <input type="range" id="sizeSlider" class="size-slider" min="100" max="800" value="282" step="1">
        <span id="sizeDisplay" style="min-width: 160px; font-size: 12px;">282px (‚âà55mm)</span>
        <span style="font-size: 11px; color: var(--muted);">‚Üê Adjust until display measures 55mm wide with ruler</span>
      </div>
      <div id="oledContainer">
        <div id="oledScaler">
          <div id="oledFrame">
            <canvas id="lowResPreview"></canvas>
          </div>
        </div>
      </div>
      <div style="margin-top: 8px; font-size: 12px; color: var(--muted);">
        <span id="peakLevel"></span>
      </div>
    </div>
  </section>

  <section style="padding-top:0;">
    <div id="warnings"></div>
  </section>

  <script type="module">
    import WaveSurfer from 'https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.esm.js';

    // Constants
    const MAX_BANK = 128;
    const LIMIT_BYTES = 26 * 1024 * 1024; // 26 MiB
    const BYTES_PER_SAMPLE = 2; // mono 16-bit
    const SAMPLE_RATE = 44100;
    const BYTES_PER_SECOND = BYTES_PER_SAMPLE * SAMPLE_RATE; // 88200
    const FS_AVAILABLE = 'showDirectoryPicker' in window && window.isSecureContext;

    // Elements
    const pickBtn = document.getElementById('pickBtn');
    const dirInput = document.getElementById('dirInput');
    const summary = document.getElementById('summary');
    const counter = document.getElementById('counter');
    const fileListEl = document.getElementById('fileList');
    const bankListEl = document.getElementById('bankList');
    const clearBtn = document.getElementById('clearBtn');
    const exportBtn = document.getElementById('exportBtn');
    const saveBtn = document.getElementById('saveToFolderBtn');
    const loadBtn = document.getElementById('loadBtn');
    const loadInput = document.getElementById('loadInput');
    const capacityInfo = document.getElementById('capacityInfo');
    const currentNameEl = document.getElementById('currentName');
    const durationEl = document.getElementById('duration');
    const warningsEl = document.getElementById('warnings');
    const enableAudioBtn = document.getElementById('enableAudioBtn');
    const lowResCanvas = document.getElementById('lowResPreview');
    const analysisInfo = document.getElementById('analysisInfo');
    const oledScaler = document.getElementById('oledScaler');
    const oledFrame = document.getElementById('oledFrame');
    const peakLevel = document.getElementById('peakLevel');
    const zoom1xBtn = document.getElementById('zoom1x');
    const zoom2xBtn = document.getElementById('zoom2x');
    const zoom3xBtn = document.getElementById('zoom3x');
    const zoom4xBtn = document.getElementById('zoom4x');
    const sizeSlider = document.getElementById('sizeSlider');
    const sizeDisplay = document.getElementById('sizeDisplay');

    // Initialize canvas with correct resolution
    lowResCanvas.width = 128;
    lowResCanvas.height = 64;

    // Physical dimensions: 55.01mm √ó 27.49mm
    const ASPECT_RATIO = 27.49 / 55.01; // height / width

    // Load saved size or use default (282px = calibrated for typical displays)
    let baseWidth = parseInt(localStorage.getItem('oledDisplayWidth') || '282');
    sizeSlider.value = baseWidth;
    sizeSlider.max = 800; // Allow up to 800px for very high DPI displays

    function updateCanvasSize() {
      const width = parseInt(sizeSlider.value);
      const height = Math.round(width * ASPECT_RATIO);

      lowResCanvas.style.width = width + 'px';
      lowResCanvas.style.height = height + 'px';

      // Update display text with approximate mm calculation
      const widthMM = (width / 7.64).toFixed(1); // Rough conversion, will vary by screen
      sizeDisplay.textContent = `${width}px (‚âà${widthMM}mm target: 55mm)`;

      // Save to localStorage
      localStorage.setItem('oledDisplayWidth', width);
      baseWidth = width;
    }

    sizeSlider.addEventListener('input', updateCanvasSize);
    updateCanvasSize(); // Initial setup

    // Click on canvas to seek
    lowResCanvas.addEventListener('click', (e) => {
      if (!wavesurfer || !wavesurfer.getDuration()) return;

      const rect = lowResCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const position = x / rect.width;

      try {
        const time = position * wavesurfer.getDuration();
        wavesurfer.seekTo(position);
        if (wavesurfer.isPlaying()) {
          wavesurfer.play();
        }
      } catch (err) {
        console.error('Seek error:', err);
      }
    });

    lowResCanvas.style.cursor = 'pointer';

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Only if not typing in an input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

      switch(e.key) {
        case ' ': // Space - play/pause
          e.preventDefault();
          if (wavesurfer && wavesurfer.getDuration() > 0) {
            wavesurfer.playPause();
          }
          break;
        case 'ArrowLeft': // Seek backward 1 second
          e.preventDefault();
          if (wavesurfer && wavesurfer.getDuration() > 0) {
            const current = wavesurfer.getCurrentTime();
            wavesurfer.seekTo(Math.max(0, current - 1) / wavesurfer.getDuration());
          }
          break;
        case 'ArrowRight': // Seek forward 1 second
          e.preventDefault();
          if (wavesurfer && wavesurfer.getDuration() > 0) {
            const current = wavesurfer.getCurrentTime();
            const duration = wavesurfer.getDuration();
            wavesurfer.seekTo(Math.min(duration, current + 1) / duration);
          }
          break;
        case 'Home': // Go to start
          e.preventDefault();
          if (wavesurfer && wavesurfer.getDuration() > 0) {
            wavesurfer.seekTo(0);
          }
          break;
        case 'End': // Go to end
          e.preventDefault();
          if (wavesurfer && wavesurfer.getDuration() > 0) {
            wavesurfer.seekTo(0.99);
          }
          break;
      }
    });

    // Setup zoom controls
    let currentZoom = 1;
    function setZoom(scale) {
      currentZoom = scale;
      oledScaler.style.transform = `scale(${scale})`;

      // Add padding to frame that scales with zoom
      const padding = 12 * scale;
      oledFrame.style.padding = `${padding}px`;

      [zoom1xBtn, zoom2xBtn, zoom3xBtn, zoom4xBtn].forEach((btn, i) => {
        btn.style.fontWeight = (i + 1) === scale ? 'bold' : 'normal';
        btn.style.background = (i + 1) === scale ? '#e0f2fe' : '#fff';
      });
    }
    zoom1xBtn.addEventListener('click', () => setZoom(1));
    zoom2xBtn.addEventListener('click', () => setZoom(2));
    zoom3xBtn.addEventListener('click', () => setZoom(3));
    zoom4xBtn.addEventListener('click', () => setZoom(4));
    setZoom(1); // Default 1√ó = physical size

    if (!FS_AVAILABLE) {
      // Hide save button if filesystem access API is not available (e.g., file:// or non-Chromium)
      saveBtn.style.display = 'none';
    }

    // State
    let wavesurfer = WaveSurfer.create({
      container: '#waveform',
      waveColor: '#9CA3AF',
      progressColor: '#1D4ED8',
      cursorColor: '#EF4444',
      height: 120,
      normalize: true,
    });
    wavesurfer.on('ready', () => {
      durationEl.textContent = formatTime(wavesurfer.getDuration());
    });

    // Track playback position for OLED preview indicator
    let currentPreviewData = null;
    let currentKeyPoints = null;
    let playbackAnimationFrame = null;

    wavesurfer.on('play', () => {
      startPlaybackIndicator();
    });

    wavesurfer.on('pause', () => {
      stopPlaybackIndicator();
    });

    wavesurfer.on('finish', () => {
      stopPlaybackIndicator();
      // Redraw without indicator but keep key points visible
      if (currentPreviewData) {
        drawInt8Preview(lowResCanvas, currentPreviewData, null, currentKeyPoints);
      }
    });

    function startPlaybackIndicator() {
      function updateIndicator() {
        if (wavesurfer.isPlaying() && currentPreviewData) {
          const currentTime = wavesurfer.getCurrentTime();
          const duration = wavesurfer.getDuration();
          const position = duration > 0 ? currentTime / duration : 0;
          drawInt8Preview(lowResCanvas, currentPreviewData, position, currentKeyPoints);
        }
        playbackAnimationFrame = requestAnimationFrame(updateIndicator);
      }
      updateIndicator();
    }

    function stopPlaybackIndicator() {
      if (playbackAnimationFrame) {
        cancelAnimationFrame(playbackAnimationFrame);
        playbackAnimationFrame = null;
      }
    }

    let entries = []; // {filename, path, nsamples, offset? , _idx}
    let selection = []; // { entry, file, sname?: string, preview128?: number[] }
    let wavMap = new Map(); // key: path/stem (lower) -> File
    let dirHandle = null; // for FS save
    let autoPreviewEnabled = false; // controlled by Enable audio toggle

    // Wire enable audio as an auto-preview toggle
    function updateAutoPreviewBtn() {
      enableAudioBtn.textContent = autoPreviewEnabled ? 'Autopreview: On' : 'Autopreview: Off';
      enableAudioBtn.className = autoPreviewEnabled ? 'toggle-on' : 'toggle-off';
    }
    updateAutoPreviewBtn();

    enableAudioBtn.addEventListener('click', async () => {
      autoPreviewEnabled = !autoPreviewEnabled;
      updateAutoPreviewBtn();
      if (autoPreviewEnabled) {
        // Try to unlock audio context by a programmatic gesture
        try { await wavesurfer.play(); wavesurfer.pause(); } catch {}
      } else {
        // Stop any current playback
        try { wavesurfer.pause(); } catch {}
      }
    });

    pickBtn.addEventListener('click', () => dirInput.click());

    dirInput.addEventListener('change', async () => {
      resetUI();
      const files = Array.from(dirInput.files || []);
      if (!files.length) return;

      const top = files[0].webkitRelativePath?.split('/')[0] || '';
      const stripTop = (p) => (p.startsWith(top + '/') ? p.slice(top.length + 1) : p);

      wavMap.clear();
      let shortJsonFile = null;
      for (const f of files) {
        const rel = stripTop(f.webkitRelativePath || f.name);
        if (/(^|\/)wav_info_short\.json$/i.test(rel)) shortJsonFile = f;
        if (/\.(wav|wave)$/i.test(f.name)) {
          const idx = rel.lastIndexOf('/');
          const dir = idx >= 0 ? rel.slice(0, idx) : '';
          const base = idx >= 0 ? rel.slice(idx + 1) : rel;
          const stem = base.replace(/\.[^.]+$/, '');
          const key = (dir ? dir + '/' : '') + stem;
          if (!wavMap.has(key.toLowerCase())) wavMap.set(key.toLowerCase(), f);
        }
      }
      if (!shortJsonFile) {
        summary.textContent = 'Could not find wav_info_short.json';
        showWarning('Select the tbdsamples folder that contains wav_info_short.json.');
        return;
      }
      try {
        const text = await shortJsonFile.text();
        const json = JSON.parse(text);
        if (!Array.isArray(json)) throw new Error('wav_info_short.json must be an array');
        entries = json.map((e, i) => ({ ...e, _idx: i }));
      } catch (e) {
        showWarning('Failed to parse wav_info_short.json: ' + e.message);
        return;
      }
      renderLeftTree();
      renderRightTree();
      updateCapacity();
      summary.textContent = `Loaded ${entries.length} entries from wav_info_short.json`;
      loadBtn.disabled = false;
    });

    function resetUI() {
      entries = [];
      selection = [];
      wavMap.clear();
      fileListEl.innerHTML = '';
      bankListEl.innerHTML = '';
      currentNameEl.textContent = 'Nothing selected';
      durationEl.textContent = '--:--';
      counter.textContent = '0/128 selected';
      capacityInfo.textContent = '';
      warningsEl.style.display = 'none';
      warningsEl.textContent = '';
      loadBtn.disabled = true;
      try { wavesurfer.empty(); } catch {}
      clearLowResCanvas();
    }

    // Tree building helpers
    function buildTree(items, getPathKey) {
      const root = { name: '', folders: new Map(), files: [] };
      for (const item of items) {
        const rel = getPathKey(item); // e.g., path/filename
        const segs = rel.split('/').filter(Boolean);
        const fname = segs.pop();
        let node = root;
        for (const seg of segs) {
          if (!node.folders.has(seg)) node.folders.set(seg, { name: seg, folders: new Map(), files: [] });
          node = node.folders.get(seg);
        }
        node.files.push(item);
      }
      // Sort folders and files
      function sortNode(node) {
        node.files.sort((a, b) => getPathKey(a).localeCompare(getPathKey(b)));
        for (const child of node.folders.values()) sortNode(child);
      }
      sortNode(root);
      return root;
    }

    function renderFolder(node, container, onLeaf) {
      // Render folders first
      const folderNames = Array.from(node.folders.keys()).sort((a, b) => a.localeCompare(b));
      for (const name of folderNames) {
        const child = node.folders.get(name);
        const details = document.createElement('details');
        details.className = 'folder';
        details.open = true;
        const summaryEl = document.createElement('summary');
        summaryEl.textContent = name;
        details.appendChild(summaryEl);
        renderFolder(child, details, onLeaf);
        container.appendChild(details);
      }
      // Render files
      for (const item of node.files) onLeaf(item, container);
    }

    // LEFT: entries not in selection
    function renderLeftTree() {
      fileListEl.innerHTML = '';
      const selectedIdx = new Set(selection.map((s) => s.entry._idx));
      const leftItems = entries.filter((e) => !selectedIdx.has(e._idx));
      const tree = buildTree(leftItems, (e) => ((e.path ? e.path + '/' : '') + e.filename));
      const freeBytes = Math.max(0, LIMIT_BYTES - totalUsedBytes());
      renderFolder(tree, fileListEl, (e, parent) => {
        const key = ((e.path ? e.path + '/' : '') + e.filename).toLowerCase();
        const f = wavMap.get(key);
        const row = document.createElement('div');
        row.className = 'leaf';
        // Size-based background color
        applySizeColor(row, bytesForEntry(e), freeBytes, true);
        const left = document.createElement('div');
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = (e.path ? e.path + '/' : '') + e.filename;
        const meta = document.createElement('div');
        meta.className = 'meta';
        const bytesTxt = formatBytes(bytesForEntry(e));
        meta.textContent = `nsamples: ${e.nsamples} ¬∑ ${bytesTxt}` + (e.offset != null ? ` ¬∑ offset: ${e.offset}` : '');
        left.appendChild(name);
        left.appendChild(meta);
        const right = document.createElement('div');
        right.className = 'right-actions';
        const btn = document.createElement('button');
        btn.textContent = 'Add';
        btn.disabled = !f;
        btn.className = 'btn';
        btn.addEventListener('click', (ev) => { ev.stopPropagation(); if (f) addToBank(e, f); });
        right.appendChild(btn);
        row.appendChild(left);
        row.appendChild(right);
        if (f) {
          row.addEventListener('mouseenter', () => { if (autoPreviewEnabled) previewBlob(e, f); });
          row.addEventListener('mouseleave', () => stopPreview());
          row.addEventListener('click', () => previewBlob(e, f));
        }
        parent.appendChild(row);
      });
    }

    // RIGHT: selection as a flat, linear list with slots
    function renderRightTree() {
      bankListEl.innerHTML = '';
      selection.forEach((s, slot) => {
        const row = document.createElement('div');
        row.className = 'leaf';
        // Size color coding (no free constraint on right)
        applySizeColor(row, bytesForEntry(s.entry), LIMIT_BYTES, false);
        // DnD wiring
        row.dataset.slot = String(slot);
        row.setAttribute('draggable', 'true');
        row.addEventListener('dragstart', (ev) => {
          ev.dataTransfer.setData('text/plain', String(slot));
          ev.dataTransfer.effectAllowed = 'move';
        });
        row.addEventListener('dragover', (ev) => { ev.preventDefault(); row.classList.add('drop-target'); ev.dataTransfer.dropEffect = 'move'; });
        row.addEventListener('dragleave', () => row.classList.remove('drop-target'));
        row.addEventListener('drop', (ev) => {
          ev.preventDefault(); row.classList.remove('drop-target');
          const src = parseInt(ev.dataTransfer.getData('text/plain'), 10);
          const dst = parseInt(row.dataset.slot || '0', 10);
          reorderSlots(src, dst);
        });

        const left = document.createElement('div');
        const name = document.createElement('div');
        name.className = 'name';
        // Slot badge
        const badge = document.createElement('span');
        badge.className = 'slot-badge';
        badge.textContent = String(slot + 1).padStart(2, ' ');
        const label = document.createElement('span');
        label.textContent = (s.entry.path ? s.entry.path + '/' : '') + s.entry.filename;
        name.appendChild(badge);
        name.appendChild(label);
        const meta = document.createElement('div');
        meta.className = 'meta';
        const bytesTxt = formatBytes(bytesForEntry(s.entry));
        meta.textContent = `nsamples: ${s.entry.nsamples} ¬∑ ${bytesTxt}` + (s.entry.offset != null ? ` ¬∑ offset: ${s.entry.offset}` : '');
        left.appendChild(name);
        left.appendChild(meta);

        const right = document.createElement('div');
        right.className = 'right-actions';
        // Short name (max 8 chars) editor
        const nameInput = document.createElement('input');
        nameInput.type = 'text';
        nameInput.maxLength = 8;
        nameInput.placeholder = 'sname';
        nameInput.value = (typeof s.sname === 'string') ? s.sname : '';
        nameInput.style.width = '8.5ch';
        nameInput.title = 'Short name (max 8 chars)';
        nameInput.addEventListener('input', () => {
          let v = nameInput.value || '';
          if (v.length > 8) v = v.slice(0, 8);
          nameInput.value = v;
          const idx = parseInt(row.dataset.slot || String(slot), 10);
          if (!isNaN(idx) && selection[idx]) selection[idx].sname = v;
        });
        right.appendChild(nameInput);
        // Remove button
        const rmBtn = document.createElement('button');
        rmBtn.textContent = 'Remove';
        rmBtn.className = 'btn';
        rmBtn.addEventListener('click', () => { removeFromBank(s.entry._idx); });
        right.appendChild(rmBtn);

        row.appendChild(left);
        row.appendChild(right);
        // Hover preview on right and row click still supported
        row.addEventListener('mouseenter', () => { if (autoPreviewEnabled) previewBlob(s.entry, s.file); });
        row.addEventListener('mouseleave', () => stopPreview());
        row.addEventListener('click', () => previewBlob(s.entry, s.file));

        bankListEl.appendChild(row);
      });
    }

    function removeFromBank(idx) {
      const i = selection.findIndex((s) => s.entry._idx === idx);
      if (i >= 0) selection.splice(i, 1);
      renderLeftTree();
      renderRightTree();
      updateSelectionUI();
    }

    function addToBank(entry, file) {
      if (selection.length >= MAX_BANK) { alert('Bank is full (128 samples).'); return; }
      // Capacity check
      const bytesNeeded = entry.nsamples * BYTES_PER_SAMPLE;
      const used = totalUsedBytes();
      if (used + bytesNeeded > LIMIT_BYTES) {
        const over = used + bytesNeeded - LIMIT_BYTES;
        showWarning(`Cannot add: capacity exceeded by ${formatBytes(over)}.`);
        return;
      }
      if (selection.find((s) => s.entry._idx === entry._idx)) return;
      const selItem = { entry, file, sname: '' };
      selection.push(selItem);
      // Generate and store 128-byte int8 preview asynchronously
      generatePreviewForFile(entry, file)
        .then((result) => {
          selItem.preview128 = Array.from(result.data);
          // If this item is currently shown in preview, redraw
          if (currentNameEl.textContent.endsWith(entry.filename)) {
            try {
              currentPreviewData = result.data;
              currentKeyPoints = result.keyPoints;
              drawInt8Preview(lowResCanvas, result.data, null, result.keyPoints);
              updateAnalysisDisplay(result.analysis, result.keyPoints);
            } catch {}
          }
        })
        .catch(() => {/* ignore preview failure */});
      renderLeftTree(); // remove from left
      renderRightTree();
      updateSelectionUI();
    }

    function updateSelectionUI() {
      counter.textContent = `${selection.length}/128 selected`;
      clearBtn.disabled = selection.length === 0;
      exportBtn.disabled = selection.length === 0;
      saveBtn.disabled = selection.length === 0 || !FS_AVAILABLE;
      updateCapacity();
    }

    clearBtn.addEventListener('click', () => { selection = []; renderLeftTree(); renderRightTree(); updateSelectionUI(); });

    function totalUsedBytes() {
      return selection.reduce((acc, s) => acc + (s.entry.nsamples * BYTES_PER_SAMPLE), 0);
    }

    function updateCapacity() {
      const used = totalUsedBytes();
      const free = Math.max(0, LIMIT_BYTES - used);
      const secs = Math.floor(free / BYTES_PER_SECOND);
      const cls = used < LIMIT_BYTES * 0.9 ? 'cap-ok' : (used <= LIMIT_BYTES ? 'cap-warn' : 'cap-err');
      capacityInfo.className = `capacity ${cls}`;
      capacityInfo.textContent = `Used ${formatBytes(used)} ¬∑ Free ${formatBytes(free)} (~${secs}s)`;
    }

    function formatBytes(n) {
      if (n >= 1024 * 1024) return (n / (1024 * 1024)).toFixed(2) + ' MiB';
      if (n >= 1024) return (n / 1024).toFixed(1) + ' KiB';
      return n + ' B';
    }

    async function previewBlob(entry, file) {
      currentNameEl.textContent = (entry.path ? entry.path + '/' : '') + entry.filename;
      durationEl.textContent = '--:--';
      try {
        wavesurfer.empty();
        await wavesurfer.loadBlob(file);
        if (autoPreviewEnabled) {
          try { wavesurfer.play(0); } catch {}
        }
      } catch (e) {
        showWarning('Failed to preview: ' + (e?.message || e));
      }
      // Generate/draw low-res preview for the current file
      try {
        // If in selection and already computed, draw immediately
        const inSel = selection.find((s) => s.entry._idx === entry._idx && s.preview128);
        if (inSel && inSel.preview128) {
          currentPreviewData = new Int8Array(inSel.preview128);
          currentKeyPoints = null; // Cached preview doesn't have key points
          drawInt8Preview(lowResCanvas, currentPreviewData, null, null);
          if (analysisInfo) analysisInfo.textContent = '';
          if (peakLevel) peakLevel.textContent = '';
        } else {
          const result = await generatePreviewForFile(entry, file);
          currentPreviewData = result.data;
          currentKeyPoints = result.keyPoints;
          drawInt8Preview(lowResCanvas, result.data, null, result.keyPoints);
          updateAnalysisDisplay(result.analysis, result.keyPoints);

          // Show peak level and size info
          if (peakLevel && result.peak) {
            const peakDB = 20 * Math.log10(result.peak / 32768);
            const peakPct = (result.peak / 32768 * 100).toFixed(1);
            const sizeKB = ((entry.nsamples * 2) / 1024).toFixed(1);

            let info = `Peak: ${peakPct}% (${peakDB.toFixed(1)}dB) ‚Ä¢ Size: ${sizeKB}KB`;

            // Add normalization indicator
            if (result.normalized) {
              info += ' ‚Ä¢ [Auto-normalized]';
            }

            // Add DC offset warning if significant
            if (result.dcOffset && Math.abs(result.dcOffset) > 500) {
              info += ` ‚Ä¢ DC: ${result.dcOffset > 0 ? '+' : ''}${Math.round(result.dcOffset)}`;
            }

            peakLevel.textContent = info;
          }
        }
      } catch {
        currentPreviewData = null;
        currentKeyPoints = null;
        clearLowResCanvas();
        if (analysisInfo) analysisInfo.textContent = '';
        if (peakLevel) peakLevel.textContent = '';
      }
    }

    function stopPreview() {
      try {
        wavesurfer.pause();
        stopPlaybackIndicator();
        // Redraw without indicator but keep key points visible
        if (currentPreviewData) {
          drawInt8Preview(lowResCanvas, currentPreviewData, null, currentKeyPoints);
        }
      } catch {}
    }

    // Export: JSN (no previews) + BIN (concatenated 128-byte int8 previews)
    async function ensureAllPreviews() {
      await Promise.all(selection.map(async (s) => {
        if (!s.preview128) {
          try {
            const result = await generatePreviewForFile(s.entry, s.file);
            s.preview128 = Array.from(result.data);
          } catch {/* ignore */}
        }
      }));
    }

    function buildSelectionJsonNoPreview() {
      const out = selection.map((s) => {
        const o = { filename: s.entry.filename, path: s.entry.path, nsamples: s.entry.nsamples };
        if (s.entry.offset != null) o.offset = s.entry.offset;
        o.sname = (typeof s.sname === 'string') ? s.sname.slice(0, 8) : '';
        return o;
      });
      return JSON.stringify(out, null, 2);
    }

    function buildPreviewBin() {
      const count = selection.length;
      const bin = new Int8Array(count * 128);
      for (let i = 0; i < count; i++) {
        const pv = selection[i].preview128 || [];
        for (let j = 0; j < 128; j++) {
          const v = (pv[j] != null ? pv[j] : 0);
          bin[i * 128 + j] = (v < 0 ? 0 : (v > 23 ? 23 : v)) | 0;
        }
      }
      return bin;
    }

    exportBtn.addEventListener('click', async () => {
      await ensureAllPreviews();
      const json = buildSelectionJsonNoPreview();
      const bin = buildPreviewBin();
      const jsonBlob = new Blob([json], { type: 'application/json' });
      const binBlob = new Blob([bin.buffer], { type: 'application/octet-stream' });
      downloadBlob(jsonBlob, 'sample_bank.jsn');
      downloadBlob(binBlob, 'sample_bank_preview.bin');
    });

    // Save to folder (FS API)
    async function ensureDirHandle() {
      if (!FS_AVAILABLE) throw new Error('File System Access API not available in this context');
      if (!dirHandle) dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
      const perm = await dirHandle.queryPermission({ mode: 'readwrite' });
      if (perm !== 'granted') {
        const p2 = await dirHandle.requestPermission({ mode: 'readwrite' });
        if (p2 !== 'granted') throw new Error('Write permission denied for selected folder');
      }
      return dirHandle;
    }
    async function verifyTbdsamples(handle) { try { await handle.getFileHandle('wav_info_short.json'); return true; } catch { return false; } }
    saveBtn.addEventListener('click', async () => {
      if (!selection.length) return;
      try {
        await ensureAllPreviews();
        const handle = await ensureDirHandle();
        const isTbds = await verifyTbdsamples(handle);
        if (!isTbds) showWarning('Selected folder does not contain wav_info_short.json. Saving sample_bank.jsn anyway.');
        // Write JSN without previews
        const jsnHandle = await handle.getFileHandle('sample_bank.jsn', { create: true });
        const jsnWritable = await jsnHandle.createWritable();
        const json = buildSelectionJsonNoPreview();
        await jsnWritable.write(json);
        await jsnWritable.close();
        // Write BIN with concatenated 128-byte previews
        const binHandle = await handle.getFileHandle('sample_bank_preview.bin', { create: true });
        const binWritable = await binHandle.createWritable();
        const bin = buildPreviewBin();
        await binWritable.write(new Blob([bin.buffer], { type: 'application/octet-stream' }));
        await binWritable.close();
        summary.textContent = 'Saved sample_bank.jsn to selected folder';
      } catch (e) { showWarning('Failed to save to folder: ' + (e?.message || e)); }
    });

    // Load JSN handlers
    loadBtn.addEventListener('click', () => loadInput.click());
    loadInput.addEventListener('change', async () => {
      const file = loadInput.files && loadInput.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        await loadBankFromJson(data);
      } catch (e) {
        showWarning('Failed to load bank JSN: ' + (e?.message || e));
      } finally {
        loadInput.value = '';
      }
    });

    async function loadBankFromJson(arr) {
      if (!Array.isArray(arr)) throw new Error('Bank JSN must be an array');
      if (!entries.length) throw new Error('Load a tbdsamples folder first');
      // Replace current bank
      selection = [];
      const usedIdx = new Set();
      let warnings = [];
      let usedBytes = 0;
      for (let i = 0; i < arr.length && selection.length < MAX_BANK; i++) {
        const it = arr[i] || {};
        const name = it.filename;
        const ns = it.nsamples;
        const off = Object.prototype.hasOwnProperty.call(it, 'offset') ? it.offset : undefined;

        // Support both legacy preview256 and new preview128 format
        let pv = null;
        if (Array.isArray(it.preview128) && it.preview128.length === 128) {
          pv = it.preview128.slice(0, 128);
        } else if (Array.isArray(it.preview256) && it.preview256.length === 256) {
          // Convert legacy 256 format to 128 by downsampling
          pv = new Array(128);
          for (let j = 0; j < 128; j++) {
            // Take max of two adjacent samples for downsampling
            const v1 = Math.abs(it.preview256[j * 2] || 0);
            const v2 = Math.abs(it.preview256[j * 2 + 1] || 0);
            const maxVal = Math.max(v1, v2);
            // Scale from 0-127 range to 0-23 range
            pv[j] = Math.min(23, Math.floor((maxVal / 127.0) * 23));
          }
        }

        const sname = (typeof it.sname === 'string') ? it.sname.slice(0, 8) : '';
        if (!name || typeof ns !== 'number') { warnings.push(`Item ${i}: missing filename/nsamples`); continue; }
        // Candidates by filename + nsamples (+offset if provided)
        let cands = entries.filter(e => e.filename === name && e.nsamples === ns);
        if (off !== undefined) cands = cands.filter(e => e.offset === off);
        // If still ambiguous, prefer not-yet-used
        let chosen = cands.find(e => !usedIdx.has(e._idx));
        // If still ambiguous or none, try filename only when unique
        if (!chosen) {
          const byName = entries.filter(e => e.filename === name);
          if (byName.length === 1) chosen = byName[0];
        }
        if (!chosen) { warnings.push(`Item ${i}: no unique match for "${name}"`); continue; }
        // Ensure file exists
        const key = ((chosen.path ? chosen.path + '/' : '') + chosen.filename).toLowerCase();
        const fileObj = wavMap.get(key);
        if (!fileObj) { warnings.push(`Item ${i}: file not found for ${key}`); continue; }
        // Capacity check
        const need = chosen.nsamples * BYTES_PER_SAMPLE;
        if (usedBytes + need > LIMIT_BYTES) { warnings.push(`Item ${i}: capacity exceeded, skipping`); continue; }
        const selItem = { entry: chosen, file: fileObj, sname };
        if (pv) selItem.preview128 = pv;
        selection.push(selItem);
        usedIdx.add(chosen._idx);
        usedBytes += need;
      }
      renderLeftTree();
      renderRightTree();
      updateSelectionUI();
      if (warnings.length) {
        showWarning(warnings.join('\n'));
      } else {
        warningsEl.style.display = 'none';
        warningsEl.textContent = '';
      }
    }

    // Helpers: size and color coding
    function bytesForEntry(e) { return (e.nsamples || 0) * BYTES_PER_SAMPLE; }
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function hsl(h, s, l){ return `hsl(${h} ${s}% ${l}%)`; }
    function applySizeColor(rowEl, bytes, freeBytes, isLeft) {
      // If left and file doesn't fit, hard red
      if (isLeft && bytes > freeBytes) {
        rowEl.style.backgroundColor = '#fee2e2'; // light red
        rowEl.style.border = '1px solid #ef4444';
        return;
      }
      const ratio = clamp01(bytes / LIMIT_BYTES);
      // Map 0->210 (blue) to 1->0 (red)
      const hue = Math.round((1 - ratio) * 210);
      rowEl.style.backgroundColor = hsl(hue, 85, 95);
      rowEl.style.border = '1px solid #e5e7eb';
    }

    function reorderSlots(src, dst) {
      if (isNaN(src) || isNaN(dst) || src === dst) return;
      const item = selection.splice(src, 1)[0];
      selection.splice(dst, 0, item);
      // Re-render right and update slot numbers, left unchanged
      renderRightTree();
      updateSelectionUI();
    }

    // Utils
    function downloadBlob(blob, name) { const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name; document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(a.href), 0); }
    function showWarning(msg) { warningsEl.style.display = 'block'; warningsEl.textContent = msg; }
    function formatTime(sec) { if (!isFinite(sec)) return '--:--'; const m = Math.floor(sec / 60); const s = Math.floor(sec % 60); return `${m}:${s.toString().padStart(2, '0')}`; }

    // Low-res preview generation and rendering
    function updateAnalysisDisplay(analysis, keyPoints = null) {
      if (!analysisInfo) return;

      if (!analysis) {
        analysisInfo.textContent = '';
        analysisInfo.title = '';
        return;
      }

      // Just show simple waveform type
      let method = '';
      if (analysis.isTransientHeavy) {
        method = '‚ö° Transient-heavy';
      } else if (analysis.isVeryQuiet) {
        method = 'üîá Quiet';
      } else if (analysis.isDense) {
        method = 'üåä Dense';
      } else if (analysis.hasSilentSections) {
        method = 'üéµ Gapped';
      } else {
        method = 'üéöÔ∏è Hybrid';
      }

      analysisInfo.textContent = method;
      analysisInfo.title = `Waveform Type: ${method}\nCrest Factor: ${analysis.crestFactor.toFixed(2)}`;
    }

    function clearLowResCanvas() {
      const ctx = lowResCanvas.getContext('2d');
      ctx.clearRect(0, 0, lowResCanvas.width, lowResCanvas.height);
    }

    async function generatePreviewForFile(entry, file) {
      const buf = await file.arrayBuffer();
      const offset = (entry && typeof entry.offset === 'number') ? entry.offset : 44;
      const nsamples = Math.max(0, entry?.nsamples | 0);

      // Generate downsampled preview data
      const previewResult = previewFromPcm16MonoBuffer(buf, offset, nsamples);

      return {
        data: previewResult.data,
        analysis: previewResult.analysis,
        keyPoints: null // Removed unreliable detection
      };
    }

    function previewFromPcm16MonoBuffer(buffer, offset, nsamples) {
      const dv = new DataView(buffer);
      const bytesPerSample = 2;
      const dataBytes = Math.max(0, dv.byteLength - offset);
      const maxSamplesFromFile = Math.floor(dataBytes / bytesPerSample);
      const total = Math.min(nsamples || maxSamplesFromFile, maxSamplesFromFile);

      // Output: 128 values (one per OLED horizontal pixel), 0-23 range (24 pixels height)
      const out = new Int8Array(128);
      if (total <= 0) return { data: out, analysis: null, peak: 0 };

      // STEP 1: Calculate DC offset (average) to remove
      let dcSum = 0;
      const dcSampleCount = Math.min(4096, total); // Sample first 4096 for DC estimate
      for (let i = 0; i < dcSampleCount; i++) {
        const byteOff = offset + i * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        dcSum += dv.getInt16(byteOff, true);
      }
      const dcOffset = dcSum / dcSampleCount;

      // STEP 2: Analyze waveform characteristics
      const analysis = analyzeWaveform(dv, offset, total, bytesPerSample);

      // STEP 3: Find true peak for optional normalization
      let globalPeak = 0;
      for (let i = 0; i < total; i += 128) { // Sample every 128 samples for speed
        const byteOff = offset + i * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        const v16 = Math.abs(dv.getInt16(byteOff, true) - dcOffset);
        if (v16 > globalPeak) globalPeak = v16;
      }

      // Decide if normalization would help (if peak < 50% of full scale)
      const shouldNormalize = globalPeak < 16384 && !analysis.isVeryQuiet;
      const normalizationFactor = shouldNormalize ? (28000 / globalPeak) : 1.0;

      // STEP 4: Generate preview with improved downsampling
      const BLOCKS = 128;
      const blockSize = total / BLOCKS;

      for (let i = 0; i < BLOCKS; i++) {
        const startIdx = Math.floor(i * blockSize);
        const endIdx = Math.floor((i + 1) * blockSize);

        let value = 0;

        if (analysis.isTransientHeavy) {
          // For drums, percussion: use peak with DC correction
          value = computeBlockPeakDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset);
        } else if (analysis.isVeryQuiet) {
          // For quiet material: use RMS with boost
          const rms = computeBlockRMSDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset);
          value = Math.min(32767, rms * 2.5);
        } else if (analysis.isDense) {
          // For dense material: balanced RMS+peak
          const peak = computeBlockPeakDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset);
          const rms = computeBlockRMSDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset);
          value = rms * 0.65 + peak * 0.35;
        } else if (analysis.hasSilentSections) {
          // For gapped material: preserve transients
          value = computeBlockPeakDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset);
        } else {
          // Default: smooth RMS-weighted
          const peak = computeBlockPeakDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset);
          const rms = computeBlockRMSDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset);
          value = rms * 0.75 + peak * 0.25;
        }

        // Apply normalization if needed
        value = Math.min(32767, value * normalizationFactor);

        // Convert to 0-23 range with perceptual curve
        const normalized = value / 32768.0;
        // Use cube root for better visibility of quiet parts (more aggressive than power 0.8)
        const compressed = Math.pow(normalized, 0.75);
        const u8 = Math.min(23, Math.floor(compressed * 23.5)); // Use 23.5 to reach full height easier

        out[i] = u8;
      }

      return {
        data: out,
        analysis: analysis,
        peak: globalPeak,
        normalized: shouldNormalize,
        dcOffset: Math.abs(dcOffset) > 100 ? dcOffset : 0
      };
    }

    // DC-corrected peak calculation
    function computeBlockPeakDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset) {
      let peakAbs = 0;
      for (let j = startIdx; j < endIdx; j++) {
        const byteOff = offset + j * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        const v16 = Math.abs(dv.getInt16(byteOff, true) - dcOffset);
        if (v16 > peakAbs) peakAbs = v16;
      }
      return peakAbs;
    }

    // DC-corrected RMS calculation
    function computeBlockRMSDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset) {
      let sumSquares = 0;
      let count = 0;
      for (let j = startIdx; j < endIdx; j++) {
        const byteOff = offset + j * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        const v16 = dv.getInt16(byteOff, true) - dcOffset;
        const abs = Math.abs(v16);
        sumSquares += abs * abs;
        count++;
      }
      return count > 0 ? Math.sqrt(sumSquares / count) : 0;
    }


    function analyzeWaveform(dv, offset, total, bytesPerSample) {
      // Sample analysis: check first 10% and last 10% for characteristics
      const sampleCount = Math.min(8192, Math.floor(total * 0.1));

      let sumAbs = 0;
      let sumSquares = 0;
      let maxPeak = 0;
      let silentSamples = 0;
      let transientCount = 0;
      let prevAbs = 0;

      const silenceThreshold = 100; // ~0.3% of full scale
      const transientThreshold = 8000; // Sudden jump indicates transient

      for (let i = 0; i < sampleCount; i++) {
        const idx = i + Math.floor(Math.random() * (total - sampleCount)); // Random sampling
        const byteOff = offset + idx * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) continue;

        const v16 = dv.getInt16(byteOff, true);
        const abs = Math.abs(v16);

        sumAbs += abs;
        sumSquares += abs * abs;
        if (abs > maxPeak) maxPeak = abs;
        if (abs < silenceThreshold) silentSamples++;

        // Detect transients (sudden changes)
        if (Math.abs(abs - prevAbs) > transientThreshold) transientCount++;
        prevAbs = abs;
      }

      const avgAbs = sumAbs / sampleCount;
      const rms = Math.sqrt(sumSquares / sampleCount);
      const crestFactor = maxPeak / (rms + 1); // Peak to RMS ratio
      const silenceRatio = silentSamples / sampleCount;
      const transientDensity = transientCount / sampleCount;

      return {
        isTransientHeavy: crestFactor > 8 && transientDensity > 0.05, // Drums, percussion
        isVeryQuiet: avgAbs < 2000, // Very quiet material needs boost
        isDense: crestFactor < 3 && silenceRatio < 0.1, // Pads, noise, drones
        hasSilentSections: silenceRatio > 0.2, // Material with gaps
        crestFactor: crestFactor,
        avgLevel: avgAbs
      };
    }

    function computeBlockPeak(dv, offset, startIdx, endIdx, bytesPerSample) {
      let peakAbs = 0;
      for (let j = startIdx; j < endIdx; j++) {
        const byteOff = offset + j * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        const v16 = dv.getInt16(byteOff, true);
        const abs = Math.abs(v16);
        if (abs > peakAbs) peakAbs = abs;
      }
      return peakAbs;
    }

    function computeBlockRMS(dv, offset, startIdx, endIdx, bytesPerSample) {
      let sumSquares = 0;
      let count = 0;
      for (let j = startIdx; j < endIdx; j++) {
        const byteOff = offset + j * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        const v16 = dv.getInt16(byteOff, true);
        const abs = Math.abs(v16);
        sumSquares += abs * abs;
        count++;
      }
      return count > 0 ? Math.sqrt(sumSquares / count) : 0;
    }

    function drawInt8Preview(canvas, data, playbackPosition = null, keyPoints = null) {
      const ctx = canvas.getContext('2d');
      const w = 128; // OLED width
      const h = 64;  // OLED height

      // Clear entire display to black (OLED off state)
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, w, h);

      // Draw sample info text at top (rows 0-38)
      if (currentNameEl && currentNameEl.textContent !== 'Nothing selected') {
        const filename = currentNameEl.textContent.split('/').pop();
        const duration = durationEl ? durationEl.textContent : '--:--';

        ctx.fillStyle = '#FFFFFF';
        ctx.font = '8px monospace';

        // Truncate filename if too long
        let displayName = filename;
        if (displayName.length > 18) {
          displayName = displayName.substring(0, 15) + '...';
        }

        // Draw filename at top
        ctx.fillText(displayName, 2, 8);

        // Draw duration and sample rate info
        ctx.font = '7px monospace';
        ctx.fillText(`${duration} | 44.1k`, 2, 18);
      }

      // Waveform preview occupies bottom third (24 pixels): rows 40-63
      const PREVIEW_START_Y = 40; // Start at pixel row 40
      const PREVIEW_HEIGHT = 24;  // 24 pixels tall
      const SAMPLES = 128;

      // For OLED emulation, we'll draw with a slight glow effect
      const imageData = ctx.createImageData(w, h);
      const pixels = imageData.data;

      // Draw waveform in bottom section with optional smoothing
      for (let x = 0; x < SAMPLES; x++) {
        const val = (data && data[x] != null) ? data[x] : 0; // 0-23

        if (val > 0) {
          // Draw vertical bar from bottom up
          for (let y = 0; y < val && y < PREVIEW_HEIGHT; y++) {
            const pixelY = h - 1 - y; // Start from bottom (row 63)
            const index = (pixelY * w + x) * 4;

            // Determine brightness with better gradient
            // Brighter at bottom, dimmer at top for depth perception
            const heightRatio = y / PREVIEW_HEIGHT;
            const brightness = 255 - (heightRatio * 80); // 255 at bottom to 175 at top

            pixels[index] = brightness;     // R
            pixels[index + 1] = brightness; // G
            pixels[index + 2] = brightness; // B
            pixels[index + 3] = 255;        // A
          }

          // Add subtle anti-aliasing at the tip for smoother appearance
          if (val < PREVIEW_HEIGHT - 1) {
            const tipY = h - 1 - val;
            if (tipY > PREVIEW_START_Y) {
              const index = (tipY * w + x) * 4;
              // Dim pixel at tip for anti-aliasing effect
              const tipBrightness = 100;
              pixels[index] = tipBrightness;
              pixels[index + 1] = tipBrightness;
              pixels[index + 2] = tipBrightness;
              pixels[index + 3] = 255;
            }
          }
        }
      }

      // Draw a subtle separator line at the top of preview area (row 39)
      for (let x = 0; x < w; x++) {
        const index = (39 * w + x) * 4;
        pixels[index] = 60;     // R - dim gray
        pixels[index + 1] = 60; // G
        pixels[index + 2] = 60; // B
        pixels[index + 3] = 255; // A
      }

      // Draw subtle division markers at 25%, 50%, 75% for reference
      // These help identify potential loop points visually
      const divisionPositions = [0.25, 0.5, 0.75];
      divisionPositions.forEach(pos => {
        const xPos = Math.floor(pos * (w - 1));
        // Draw a very subtle vertical line (1 pixel, bottom of waveform area)
        const yPos = h - 1;
        const index = (yPos * w + xPos) * 4;
        pixels[index] = 120;     // R - subtle marker
        pixels[index + 1] = 120; // G
        pixels[index + 2] = 120; // B
        pixels[index + 3] = 255; // A
      });

      // Draw playback position indicator if provided (no other markers)
      if (playbackPosition !== null && playbackPosition >= 0 && playbackPosition <= 1) {
        const indicatorX = Math.floor(playbackPosition * (w - 1));

        // Draw vertical line from top to bottom of preview area (rows 40-63)
        for (let y = PREVIEW_START_Y; y < h; y++) {
          const index = (y * w + indicatorX) * 4;
          // Invert colors - make it bright where waveform is dark, dark where bright
          const currentBrightness = pixels[index];
          const inverted = currentBrightness > 128 ? 0 : 255;

          pixels[index] = inverted;     // R
          pixels[index + 1] = inverted; // G
          pixels[index + 2] = inverted; // B
          pixels[index + 3] = 255;      // A
        }
      }

      ctx.putImageData(imageData, 0, 0);

      // Add OLED glow effect (subtle)
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 0.8;
      ctx.globalAlpha = 0.25;
      ctx.drawImage(canvas, 0, 0);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1.0;

      // Optional: Add scan lines for more authentic OLED look (very subtle)
      ctx.globalAlpha = 0.03;
      ctx.fillStyle = '#000000';
      for (let y = 0; y < h; y += 2) {
        ctx.fillRect(0, y, w, 1);
      }
      ctx.globalAlpha = 1.0;
    }
  </script>
</body>
</html>
