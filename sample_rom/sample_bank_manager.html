<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Sample Bank Builder (128)</title>
  <style>
    :root { --b:#e5e7eb; --t:#111827; --muted:#6b7280; --pri:#334155; --acc:#1d4ed8; }
    * { box-sizing: border-box; }
    body { margin: 0; font: 14px/1.4 -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color: var(--t); }
    header, section { padding: 12px 16px; }
    header { position: sticky; top: 0; background: #fff; border-bottom: 1px solid var(--b); z-index: 10; }
    h1 { font-size: 16px; margin: 0 0 8px; }
    .row { display: flex; gap: 8px; align-items: center; flex-wrap: wrap; }
    button { padding: 6px 10px; border: 1px solid var(--b); background: #fff; border-radius: 6px; cursor: pointer; }
    button:disabled { opacity: .5; cursor: default; }
    .pill { background: #eef; border: 1px solid #cfe; border-radius: 999px; padding: 2px 8px; font-size: 12px; }
    .muted { color: var(--muted); }
    #browser { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    #fileList, #bankList { border: 1px solid var(--b); border-radius: 6px; overflow: auto; height: 360px; padding: 6px; }
    .item { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; padding: 6px 4px; border-bottom: 1px dotted var(--b); }
    .item:last-child { border-bottom: 0; }
    .name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .meta { font-size: 12px; color: var(--muted); }
    #preview { border-top: 1px solid var(--b); padding-top: 12px; }
    #waveform { height: 120px; border: 1px solid var(--b); border-radius: 6px; }
  #lowResRow { margin-top: 8px; }
  #lowResLabel { font-weight: 600; margin-right: 8px; }
  #lowResPreview {
    display: block;
    image-rendering: pixelated;
    image-rendering: crisp-edges;
    image-rendering: -moz-crisp-edges;
    background: #000;
    /* Size controlled by JavaScript slider for accurate physical dimension calibration */
  }
  #oledContainer {
    display: inline-block;
    position: relative;
  }
  #oledFrame {
    background: linear-gradient(145deg, #1a1a1a, #2a2a2a);
    border-radius: 8px;
    box-shadow: inset 0 2px 8px rgba(0,0,0,0.5);
    position: relative;
  }
  #oledActiveArea {
    position: absolute;
    background: #000;
    pointer-events: none;
  }
  #oledScaler {
    transform-origin: top left;
    transition: transform 0.2s ease;
    position: relative;
  }
  .zoom-controls {
    display: inline-flex;
    gap: 4px;
    margin-left: 12px;
  }
  .zoom-btn {
    padding: 4px 8px;
    font-size: 11px;
    min-width: 40px;
  }
  .display-info {
    font-size: 11px;
    color: var(--muted);
    margin-left: 12px;
  }
  .size-calibration {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 8px;
    padding: 8px;
    background: #f9fafb;
    border-radius: 4px;
    border: 1px solid var(--b);
  }
  .size-slider {
    width: 200px;
  }
    #warnings { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace; background: #fff7ed; border: 1px solid #fed7aa; color: #9a3412; border-radius: 6px; padding: 8px; display: none; }
    .folder { margin: 4px 0; }
    .folder > summary { cursor: pointer; font-weight: 600; }
    .leaf { display: grid; grid-template-columns: 1fr auto; align-items: center; gap: 8px; padding: 4px 2px; border-bottom: 1px dotted var(--b); }
    .leaf .name { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
    .leaf .meta { font-size: 12px; color: var(--muted); }
    .right-actions .btn { margin-left: 6px; }
    .capacity { font-size: 12px; color: var(--muted); }
    .cap-ok { color: #065f46; }
    .cap-warn { color: #92400e; }
    .cap-err { color: #991b1b; }
    .toggle-on { background: #e0f2fe; border-color: #7dd3fc; }
    .toggle-off { background: #f3f4f6; border-color: #d1d5db; }
    .slot-badge { display: inline-block; min-width: 1.8em; text-align: right; margin-right: 8px; color: #374151; font-weight: 600; }
    .drop-target { outline: 2px dashed #60a5fa; outline-offset: 2px; }

    /* Tag System Styles */
    .tag-btn {
      padding: 3px 8px;
      font-size: 10px;
      border-radius: 10px;
      border: 1px solid #d1d5db;
      background: white;
      color: #374151;
      cursor: pointer;
      transition: all 0.15s;
    }
    .tag-btn:hover {
      background: #f3f4f6;
      border-color: #9ca3af;
    }
    .tag-btn.active {
      background: #3b82f6;
      color: white;
      border-color: #2563eb;
    }
    .tag-badge {
      display: inline-flex;
      align-items: center;
      gap: 3px;
      padding: 3px 7px;
      font-size: 10px;
      border-radius: 10px;
      background: #3b82f6;
      color: white;
      font-weight: 500;
    }
    .tag-badge .remove {
      cursor: pointer;
      font-weight: bold;
      opacity: 0.8;
      margin-left: 2px;
      font-size: 12px;
    }
    .tag-badge .remove:hover {
      opacity: 1;
    }
    .tag-mini {
      font-size: 10px;
      padding: 3px 7px;
      border-radius: 10px;
      background: #3b82f6;
      color: white;
      font-weight: 500;
      display: inline-block;
      white-space: nowrap;
    }
    #floatingTagPanel {
      animation: fadeIn 0.15s ease-in;
    }
    @keyframes fadeIn {
      from { opacity: 0; transform: translateY(-5px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .leaf:hover {
      background: #f9fafb;
    }
    #bankList .leaf {
      border-bottom: 1px solid #e5e7eb;
      transition: background 0.1s;
    }
    #bankList .leaf:last-child {
      border-bottom: none;
    }
  </style>
</head>
<body>
  <header>
    <h1>Sample Bank Builder (128)</h1>
    <div class="row">
      <input id="dirInput" type="file" webkitdirectory multiple hidden />
      <button id="pickBtn">Pick tbdsamples folder…</button>
      <span id="summary" class="muted">No folder loaded</span>
      <span id="counter" class="pill">0/128 selected</span>
      <button id="enableAudioBtn" title="Click once if your browser blocks autoplay">Enable audio</button>
    </div>
  </header>

  <section id="browser">
    <div>
      <div class="row" style="margin-bottom:6px; justify-content: space-between;">
        <strong>Converted files</strong>
        <span class="muted">Hover to preview • Click Add to select</span>
      </div>
      <div id="fileList"></div>
    </div>
    <div>
      <div class="row" style="margin-bottom:6px; justify-content: space-between; align-items: baseline;">
        <strong>Selected bank</strong>
        <div class="row">
          <span id="capacityInfo" class="capacity"></span>
          <input id="loadInput" type="file" accept=".jsn" hidden />
          <button id="loadBtn" disabled>Load JSN</button>
          <button id="clearBtn" disabled>Clear</button>
          <button id="exportBtn" disabled>Export JSN</button>
          <button id="saveToFolderBtn" disabled>Save to folder</button>
        </div>
      </div>
      <div id="bankList"></div>
    </div>
  </section>

  <section id="preview">
    <div class="row" style="justify-content: space-between;">
      <div class="row">
        <strong>Preview:</strong>
        <span id="currentName" class="muted">Nothing selected</span>
        <span id="duration" class="pill">--:--</span>
      </div>
    </div>
    <div id="waveform"></div>
      <div id="lowResRow">
      <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px; flex-wrap: wrap;">
        <span id="lowResLabel">2.42" OLED Preview (128×64 monochrome):</span>
        <span id="analysisInfo" class="pill" style="font-size: 11px;"></span>
        <div class="zoom-controls">
          <button id="zoom1x" class="zoom-btn">1×</button>
          <button id="zoom2x" class="zoom-btn">2×</button>
          <button id="zoom3x" class="zoom-btn">3×</button>
          <button id="zoom4x" class="zoom-btn">4×</button>
        </div>
        <span class="display-info">Click waveform to seek • Space=Play/Pause</span>
      </div>
      <div class="size-calibration">
        <label for="sizeSlider" style="font-weight: 600; white-space: nowrap;">Physical Size:</label>
        <input type="range" id="sizeSlider" class="size-slider" min="100" max="800" value="282" step="1">
        <span id="sizeDisplay" style="min-width: 160px; font-size: 12px;">282px (≈55mm)</span>
        <span style="font-size: 11px; color: var(--muted);">← Adjust until display measures 55mm wide with ruler</span>
      </div>
      <div id="oledContainer">
        <div id="oledScaler">
          <div id="oledFrame">
            <canvas id="lowResPreview"></canvas>
          </div>
        </div>
      </div>
      <div style="margin-top: 8px; font-size: 12px; color: var(--muted);">
        <span id="peakLevel"></span>
      </div>
    </div>

    <!-- Floating Tag Panel (shown on hover) -->
    <div id="floatingTagPanel" style="display: none; position: fixed; z-index: 1000; background: white; border: 2px solid #3b82f6; border-radius: 6px; padding: 12px; box-shadow: 0 10px 25px rgba(0,0,0,0.2); max-width: 400px; min-width: 320px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid #e5e7eb;">
        <strong style="font-size: 13px;">Edit Sample</strong>
        <button id="closeTagPanelBtn" style="font-size: 10px; padding: 2px 6px; background: #ef4444; color: white; border: none;">✕</button>
      </div>

      <!-- Sample Name Input -->
      <div style="margin-bottom: 10px;">
        <label style="display: block; font-size: 11px; color: #6b7280; margin-bottom: 4px; font-weight: 500;">Sample Name (max 8 chars):</label>
        <input id="sampleNameInput" type="text" maxlength="8" placeholder="Enter name..." style="width: 100%; padding: 6px 8px; font-size: 12px; border: 1px solid #d1d5db; border-radius: 3px;">
      </div>

      <!-- Tags Section -->
      <div style="margin-bottom: 6px; display: flex; justify-content: space-between; align-items: center;">
        <strong style="font-size: 11px; color: #6b7280;">Tags:</strong>
        <button id="clearTagsBtn" style="font-size: 10px; padding: 2px 6px;">Clear All</button>
      </div>
      <div id="currentTags" style="display: flex; flex-wrap: wrap; gap: 4px; min-height: 24px; margin-bottom: 8px; padding: 6px; background: #f9fafb; border: 1px solid #e5e7eb; border-radius: 3px; max-height: 60px; overflow-y: auto;">
        <span style="color: #9ca3af; font-size: 11px;">No tags</span>
      </div>
      <div style="margin-bottom: 6px;">
        <strong style="font-size: 11px; color: #6b7280;">Quick Tags:</strong>
      </div>
      <div id="tagCloud" style="display: flex; flex-wrap: wrap; gap: 4px; max-height: 180px; overflow-y: auto; padding: 4px;">
        <!-- Tag buttons will be inserted here -->
      </div>
      <div style="margin-top: 8px; display: flex; gap: 4px; padding-top: 8px; border-top: 1px solid #e5e7eb;">
        <input id="customTagInput" type="text" placeholder="Custom tag..." style="flex: 1; padding: 4px 8px; font-size: 11px; border: 1px solid #d1d5db; border-radius: 3px;">
        <button id="addCustomTagBtn" style="padding: 4px 10px; font-size: 11px;">+</button>
      </div>
    </div>
  </section>

  <section style="padding-top:0;">
    <div id="warnings"></div>
  </section>

  <script type="module">
    import WaveSurfer from 'https://unpkg.com/wavesurfer.js@7/dist/wavesurfer.esm.js';

    // Constants
    const MAX_BANK = 128;
    const LIMIT_BYTES = 26 * 1024 * 1024; // 26 MiB
    const BYTES_PER_SAMPLE = 2; // mono 16-bit
    const SAMPLE_RATE = 44100;
    const BYTES_PER_SECOND = BYTES_PER_SAMPLE * SAMPLE_RATE; // 88200
    const FS_AVAILABLE = 'showDirectoryPicker' in window && window.isSecureContext;

    // Elements
    const pickBtn = document.getElementById('pickBtn');
    const dirInput = document.getElementById('dirInput');
    const summary = document.getElementById('summary');
    const counter = document.getElementById('counter');
    const fileListEl = document.getElementById('fileList');
    const bankListEl = document.getElementById('bankList');
    const clearBtn = document.getElementById('clearBtn');
    const exportBtn = document.getElementById('exportBtn');
    const saveBtn = document.getElementById('saveToFolderBtn');
    const loadBtn = document.getElementById('loadBtn');
    const loadInput = document.getElementById('loadInput');
    const capacityInfo = document.getElementById('capacityInfo');
    const currentNameEl = document.getElementById('currentName');
    const durationEl = document.getElementById('duration');
    const warningsEl = document.getElementById('warnings');
    const enableAudioBtn = document.getElementById('enableAudioBtn');
    const lowResCanvas = document.getElementById('lowResPreview');
    const analysisInfo = document.getElementById('analysisInfo');
    const oledScaler = document.getElementById('oledScaler');
    const oledFrame = document.getElementById('oledFrame');
    const peakLevel = document.getElementById('peakLevel');
    const zoom1xBtn = document.getElementById('zoom1x');
    const zoom2xBtn = document.getElementById('zoom2x');
    const zoom3xBtn = document.getElementById('zoom3x');
    const zoom4xBtn = document.getElementById('zoom4x');
    const sizeSlider = document.getElementById('sizeSlider');
    const sizeDisplay = document.getElementById('sizeDisplay');

    // Initialize canvas with correct resolution
    lowResCanvas.width = 128;
    lowResCanvas.height = 64;

    // Physical dimensions: 55.01mm × 27.49mm
    const ASPECT_RATIO = 27.49 / 55.01; // height / width

    // Load saved size or use default (282px = calibrated for typical displays)
    let baseWidth = parseInt(localStorage.getItem('oledDisplayWidth') || '282');
    sizeSlider.value = baseWidth;
    sizeSlider.max = 800; // Allow up to 800px for very high DPI displays

    function updateCanvasSize() {
      const width = parseInt(sizeSlider.value);
      const height = Math.round(width * ASPECT_RATIO);

      lowResCanvas.style.width = width + 'px';
      lowResCanvas.style.height = height + 'px';

      // Update display text with approximate mm calculation
      const widthMM = (width / 7.64).toFixed(1); // Rough conversion, will vary by screen
      sizeDisplay.textContent = `${width}px (≈${widthMM}mm target: 55mm)`;

      // Save to localStorage
      localStorage.setItem('oledDisplayWidth', width);
      baseWidth = width;
    }

    sizeSlider.addEventListener('input', updateCanvasSize);
    updateCanvasSize(); // Initial setup

    // Click on canvas to seek
    lowResCanvas.addEventListener('click', (e) => {
      if (!wavesurfer || !wavesurfer.getDuration()) return;

      const rect = lowResCanvas.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const position = x / rect.width;

      try {
        const time = position * wavesurfer.getDuration();
        wavesurfer.seekTo(position);
        if (wavesurfer.isPlaying()) {
          wavesurfer.play();
        }
      } catch (err) {
        console.error('Seek error:', err);
      }
    });

    lowResCanvas.style.cursor = 'pointer';

    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
      // Only if not typing in an input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

      switch(e.key) {
        case ' ': // Space - play/pause
          e.preventDefault();
          if (wavesurfer && wavesurfer.getDuration() > 0) {
            wavesurfer.playPause();
          }
          break;
        case 'ArrowLeft': // Seek backward 1 second
          e.preventDefault();
          if (wavesurfer && wavesurfer.getDuration() > 0) {
            const current = wavesurfer.getCurrentTime();
            wavesurfer.seekTo(Math.max(0, current - 1) / wavesurfer.getDuration());
          }
          break;
        case 'ArrowRight': // Seek forward 1 second
          e.preventDefault();
          if (wavesurfer && wavesurfer.getDuration() > 0) {
            const current = wavesurfer.getCurrentTime();
            const duration = wavesurfer.getDuration();
            wavesurfer.seekTo(Math.min(duration, current + 1) / duration);
          }
          break;
        case 'Home': // Go to start
          e.preventDefault();
          if (wavesurfer && wavesurfer.getDuration() > 0) {
            wavesurfer.seekTo(0);
          }
          break;
        case 'End': // Go to end
          e.preventDefault();
          if (wavesurfer && wavesurfer.getDuration() > 0) {
            wavesurfer.seekTo(0.99);
          }
          break;
      }
    });

    // Setup zoom controls
    let currentZoom = 1;
    function setZoom(scale) {
      currentZoom = scale;
      oledScaler.style.transform = `scale(${scale})`;

      // Add padding to frame that scales with zoom
      const padding = 12 * scale;
      oledFrame.style.padding = `${padding}px`;

      [zoom1xBtn, zoom2xBtn, zoom3xBtn, zoom4xBtn].forEach((btn, i) => {
        btn.style.fontWeight = (i + 1) === scale ? 'bold' : 'normal';
        btn.style.background = (i + 1) === scale ? '#e0f2fe' : '#fff';
      });
    }
    zoom1xBtn.addEventListener('click', () => setZoom(1));
    zoom2xBtn.addEventListener('click', () => setZoom(2));
    zoom3xBtn.addEventListener('click', () => setZoom(3));
    zoom4xBtn.addEventListener('click', () => setZoom(4));
    setZoom(1); // Default 1× = physical size

    if (!FS_AVAILABLE) {
      // Hide save button if filesystem access API is not available (e.g., file:// or non-Chromium)
      saveBtn.style.display = 'none';
    }

    // State
    let wavesurfer = WaveSurfer.create({
      container: '#waveform',
      waveColor: '#9CA3AF',
      progressColor: '#1D4ED8',
      cursorColor: '#EF4444',
      height: 120,
      normalize: true,
    });
    wavesurfer.on('ready', () => {
      durationEl.textContent = formatTime(wavesurfer.getDuration());
    });

    // Track playback position for OLED preview indicator
    let currentPreviewData = null;
    let currentKeyPoints = null;
    let currentSpectral = null;
    let playbackAnimationFrame = null;

    // Tag System State
    let currentSelectedFile = null; // Track currently selected file for tagging
    const predefinedTags = [
      // Instrument Types
      'kick', 'snare', 'clap', 'hihat', 'cymbal', 'tom', 'percussion',
      'bass', 'lead', 'pad', 'pluck', 'chord', 'stab',
      // Characteristics
      'short', 'long', 'percussive', 'melodic', 'atonal', 'tonal',
      'bright', 'dark', 'warm', 'cold', 'clean', 'distorted',
      'wet', 'dry', 'ambient', 'aggressive', 'soft', 'hard',
      // Effects/Processing
      'reverb', 'delay', 'filtered', 'modulated', 'compressed',
      // Genres/Styles
      'techno', 'house', 'dub', 'industrial', 'ambient', 'experimental'
    ];

    // Initialize tag cloud UI
    const tagCloudEl = document.getElementById('tagCloud');
    const currentTagsEl = document.getElementById('currentTags');
    const customTagInput = document.getElementById('customTagInput');
    const addCustomTagBtn = document.getElementById('addCustomTagBtn');
    const clearTagsBtn = document.getElementById('clearTagsBtn');
    const floatingTagPanel = document.getElementById('floatingTagPanel');
    const closeTagPanelBtn = document.getElementById('closeTagPanelBtn');
    const sampleNameInput = document.getElementById('sampleNameInput');

    let tagPanelTimeout = null;
    let isTagPanelPinned = false;

    // Show floating tag panel near mouse position
    function showTagPanel(x, y, rowElement) {
      clearTimeout(tagPanelTimeout);

      floatingTagPanel.style.display = 'block';

      // Position panel to the right of cursor, or left if too close to edge
      const panelWidth = 400;
      const panelHeight = floatingTagPanel.offsetHeight || 400;
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      let left = x + 20; // 20px to the right of cursor
      let top = y - 20; // 20px above cursor

      // If too close to right edge, show on left
      if (left + panelWidth > viewportWidth - 20) {
        left = x - panelWidth - 20;
      }

      // If too close to left edge, clamp
      if (left < 20) {
        left = 20;
      }

      // If too close to bottom, move up
      if (top + panelHeight > viewportHeight - 20) {
        top = viewportHeight - panelHeight - 20;
      }

      // If too close to top, clamp
      if (top < 20) {
        top = 20;
      }

      floatingTagPanel.style.left = left + 'px';
      floatingTagPanel.style.top = top + 'px';
    }

    // Hide floating tag panel with delay
    function hideTagPanel(immediate = false) {
      if (isTagPanelPinned) return;

      if (immediate) {
        clearTimeout(tagPanelTimeout);
        floatingTagPanel.style.display = 'none';
      } else {
        clearTimeout(tagPanelTimeout);
        tagPanelTimeout = setTimeout(() => {
          if (!isTagPanelPinned) {
            floatingTagPanel.style.display = 'none';
          }
        }, 300); // 300ms delay before hiding
      }
    }

    // Keep panel open when hovering over it
    floatingTagPanel.addEventListener('mouseenter', () => {
      clearTimeout(tagPanelTimeout);
      isTagPanelPinned = true;
    });

    floatingTagPanel.addEventListener('mouseleave', () => {
      isTagPanelPinned = false;
      hideTagPanel();
    });

    // Close button
    closeTagPanelBtn.addEventListener('click', () => {
      isTagPanelPinned = false;
      hideTagPanel(true);
    });

    // Create tag cloud buttons
    predefinedTags.forEach(tag => {
      const btn = document.createElement('button');
      btn.className = 'tag-btn';
      btn.textContent = tag;
      btn.dataset.tag = tag;
      btn.addEventListener('click', () => toggleTag(tag));
      tagCloudEl.appendChild(btn);
    });

    // Get tags for currently selected file/entry
    function getCurrentTags() {
      if (!currentSelectedFile) return [];
      return currentSelectedFile.tags || [];
    }

    // Set tags for currently selected file/entry
    function setCurrentTags(tags) {
      if (!currentSelectedFile) return;
      currentSelectedFile.tags = [...new Set(tags)]; // Deduplicate
      updateTagDisplay();
      updateBankListTags(); // Update tags in bank list if this file is in selection
    }

    // Toggle a tag on/off
    function toggleTag(tag) {
      const tags = getCurrentTags();
      const index = tags.indexOf(tag);
      if (index === -1) {
        tags.push(tag);
      } else {
        tags.splice(index, 1);
      }
      setCurrentTags(tags);
    }

    // Update the tag display (current tags + tag cloud button states)
    function updateTagDisplay() {
      const tags = getCurrentTags();

      // Update sample name input
      if (currentSelectedFile) {
        sampleNameInput.value = currentSelectedFile.sname || '';
      } else {
        sampleNameInput.value = '';
      }

      // Update current tags display
      currentTagsEl.innerHTML = '';
      if (tags.length === 0) {
        const placeholder = document.createElement('span');
        placeholder.style.color = '#9ca3af';
        placeholder.style.fontSize = '12px';
        placeholder.textContent = 'No tags selected';
        currentTagsEl.appendChild(placeholder);
      } else {
        tags.forEach(tag => {
          const badge = document.createElement('span');
          badge.className = 'tag-badge';
          badge.innerHTML = `${tag}<span class="remove" data-tag="${tag}">×</span>`;
          badge.querySelector('.remove').addEventListener('click', () => toggleTag(tag));
          currentTagsEl.appendChild(badge);
        });
      }

      // Update tag cloud button states
      tagCloudEl.querySelectorAll('.tag-btn').forEach(btn => {
        if (tags.includes(btn.dataset.tag)) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
    }

    // Add custom tag
    addCustomTagBtn.addEventListener('click', () => {
      const customTag = customTagInput.value.trim().toLowerCase();
      if (customTag && customTag.length > 0) {
        const tags = getCurrentTags();
        if (!tags.includes(customTag)) {
          tags.push(customTag);
          setCurrentTags(tags);
        }
        customTagInput.value = '';
      }
    });

    // Enter key in custom tag input
    customTagInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        addCustomTagBtn.click();
      }
    });

    // Clear all tags
    clearTagsBtn.addEventListener('click', () => {
      if (currentSelectedFile) {
        setCurrentTags([]);
      }
    });

    // Sample name input handler
    sampleNameInput.addEventListener('input', () => {
      if (!currentSelectedFile) return;
      let v = sampleNameInput.value || '';
      if (v.length > 8) v = v.slice(0, 8);
      sampleNameInput.value = v;
      currentSelectedFile.sname = v;
      updateBankListTags(); // Refresh display
    });

    // Update tags in bank list display
    function updateBankListTags() {
      // Find this file in selection and update its display
      const selItem = selection.find(s => s.entry._idx === currentSelectedFile?.entry?._idx);
      if (selItem) {
        renderRightTree();
      }
    }

    wavesurfer.on('play', () => {
      startPlaybackIndicator();
    });

    wavesurfer.on('pause', () => {
      stopPlaybackIndicator();
    });

    wavesurfer.on('finish', () => {
      stopPlaybackIndicator();
      // Redraw without indicator but keep key points and spectral visible
      if (currentPreviewData) {
        drawInt8Preview(lowResCanvas, currentPreviewData, null, currentKeyPoints, currentSpectral);
      }
    });

    function startPlaybackIndicator() {
      function updateIndicator() {
        if (wavesurfer.isPlaying() && currentPreviewData) {
          const currentTime = wavesurfer.getCurrentTime();
          const duration = wavesurfer.getDuration();
          const position = duration > 0 ? currentTime / duration : 0;
          drawInt8Preview(lowResCanvas, currentPreviewData, position, currentKeyPoints, currentSpectral);
        }
        playbackAnimationFrame = requestAnimationFrame(updateIndicator);
      }
      updateIndicator();
    }

    function stopPlaybackIndicator() {
      if (playbackAnimationFrame) {
        cancelAnimationFrame(playbackAnimationFrame);
        playbackAnimationFrame = null;
      }
    }

    let entries = []; // {filename, path, nsamples, offset? , _idx}
    let selection = []; // { entry, file, sname?: string, preview128?: number[] }
    let wavMap = new Map(); // key: path/stem (lower) -> File
    let dirHandle = null; // for FS save
    let autoPreviewEnabled = false; // controlled by Enable audio toggle

    // Wire enable audio as an auto-preview toggle
    function updateAutoPreviewBtn() {
      enableAudioBtn.textContent = autoPreviewEnabled ? 'Autopreview: On' : 'Autopreview: Off';
      enableAudioBtn.className = autoPreviewEnabled ? 'toggle-on' : 'toggle-off';
    }
    updateAutoPreviewBtn();

    enableAudioBtn.addEventListener('click', async () => {
      autoPreviewEnabled = !autoPreviewEnabled;
      updateAutoPreviewBtn();
      if (autoPreviewEnabled) {
        // Try to unlock audio context by a programmatic gesture
        try { await wavesurfer.play(); wavesurfer.pause(); } catch {}
      } else {
        // Stop any current playback
        try { wavesurfer.pause(); } catch {}
      }
    });

    pickBtn.addEventListener('click', () => dirInput.click());

    dirInput.addEventListener('change', async () => {
      resetUI();
      const files = Array.from(dirInput.files || []);
      if (!files.length) return;

      const top = files[0].webkitRelativePath?.split('/')[0] || '';
      const stripTop = (p) => (p.startsWith(top + '/') ? p.slice(top.length + 1) : p);

      wavMap.clear();
      let shortJsonFile = null;
      for (const f of files) {
        const rel = stripTop(f.webkitRelativePath || f.name);
        if (/(^|\/)wav_info_short\.json$/i.test(rel)) shortJsonFile = f;
        if (/\.(wav|wave)$/i.test(f.name)) {
          const idx = rel.lastIndexOf('/');
          const dir = idx >= 0 ? rel.slice(0, idx) : '';
          const base = idx >= 0 ? rel.slice(idx + 1) : rel;
          const stem = base.replace(/\.[^.]+$/, '');
          const key = (dir ? dir + '/' : '') + stem;
          if (!wavMap.has(key.toLowerCase())) wavMap.set(key.toLowerCase(), f);
        }
      }
      if (!shortJsonFile) {
        summary.textContent = 'Could not find wav_info_short.json';
        showWarning('Select the tbdsamples folder that contains wav_info_short.json.');
        return;
      }
      try {
        const text = await shortJsonFile.text();
        const json = JSON.parse(text);
        if (!Array.isArray(json)) throw new Error('wav_info_short.json must be an array');
        entries = json.map((e, i) => ({ ...e, _idx: i }));
      } catch (e) {
        showWarning('Failed to parse wav_info_short.json: ' + e.message);
        return;
      }
      renderLeftTree();
      renderRightTree();
      updateCapacity();
      summary.textContent = `Loaded ${entries.length} entries from wav_info_short.json`;
      loadBtn.disabled = false;
    });

    function resetUI() {
      entries = [];
      selection = [];
      wavMap.clear();
      fileListEl.innerHTML = '';
      bankListEl.innerHTML = '';
      currentNameEl.textContent = 'Nothing selected';
      durationEl.textContent = '--:--';
      counter.textContent = '0/128 selected';
      capacityInfo.textContent = '';
      warningsEl.style.display = 'none';
      warningsEl.textContent = '';
      loadBtn.disabled = true;
      try { wavesurfer.empty(); } catch {}
      clearLowResCanvas();
    }

    // Tree building helpers
    function buildTree(items, getPathKey) {
      const root = { name: '', folders: new Map(), files: [] };
      for (const item of items) {
        const rel = getPathKey(item); // e.g., path/filename
        const segs = rel.split('/').filter(Boolean);
        const fname = segs.pop();
        let node = root;
        for (const seg of segs) {
          if (!node.folders.has(seg)) node.folders.set(seg, { name: seg, folders: new Map(), files: [] });
          node = node.folders.get(seg);
        }
        node.files.push(item);
      }
      // Sort folders and files
      function sortNode(node) {
        node.files.sort((a, b) => getPathKey(a).localeCompare(getPathKey(b)));
        for (const child of node.folders.values()) sortNode(child);
      }
      sortNode(root);
      return root;
    }

    function renderFolder(node, container, onLeaf) {
      // Render folders first
      const folderNames = Array.from(node.folders.keys()).sort((a, b) => a.localeCompare(b));
      for (const name of folderNames) {
        const child = node.folders.get(name);
        const details = document.createElement('details');
        details.className = 'folder';
        details.open = true;
        const summaryEl = document.createElement('summary');
        summaryEl.textContent = name;
        details.appendChild(summaryEl);
        renderFolder(child, details, onLeaf);
        container.appendChild(details);
      }
      // Render files
      for (const item of node.files) onLeaf(item, container);
    }

    // LEFT: entries not in selection
    function renderLeftTree() {
      fileListEl.innerHTML = '';
      const selectedIdx = new Set(selection.map((s) => s.entry._idx));
      const leftItems = entries.filter((e) => !selectedIdx.has(e._idx));
      const tree = buildTree(leftItems, (e) => ((e.path ? e.path + '/' : '') + e.filename));
      const freeBytes = Math.max(0, LIMIT_BYTES - totalUsedBytes());
      renderFolder(tree, fileListEl, (e, parent) => {
        const key = ((e.path ? e.path + '/' : '') + e.filename).toLowerCase();
        const f = wavMap.get(key);
        const row = document.createElement('div');
        row.className = 'leaf';
        // Size-based background color
        applySizeColor(row, bytesForEntry(e), freeBytes, true);
        const left = document.createElement('div');
        const name = document.createElement('div');
        name.className = 'name';
        name.textContent = (e.path ? e.path + '/' : '') + e.filename;
        const meta = document.createElement('div');
        meta.className = 'meta';
        const bytesTxt = formatBytes(bytesForEntry(e));
        meta.textContent = `nsamples: ${e.nsamples} · ${bytesTxt}` + (e.offset != null ? ` · offset: ${e.offset}` : '');
        left.appendChild(name);
        left.appendChild(meta);
        const right = document.createElement('div');
        right.className = 'right-actions';
        const btn = document.createElement('button');
        btn.textContent = 'Add';
        btn.disabled = !f;
        btn.className = 'btn';
        btn.addEventListener('click', (ev) => { ev.stopPropagation(); if (f) addToBank(e, f); });
        right.appendChild(btn);
        row.appendChild(left);
        row.appendChild(right);
        if (f) {
          row.addEventListener('mouseenter', () => { if (autoPreviewEnabled) previewBlob(e, f); });
          row.addEventListener('mouseleave', () => stopPreview());
          row.addEventListener('click', () => previewBlob(e, f));
        }
        parent.appendChild(row);
      });
    }

    // RIGHT: selection as a flat, linear list with slots
    function renderRightTree() {
      bankListEl.innerHTML = '';
      selection.forEach((s, slot) => {
        const row = document.createElement('div');
        row.className = 'leaf';
        // Size color coding (no free constraint on right)
        applySizeColor(row, bytesForEntry(s.entry), LIMIT_BYTES, false);
        // DnD wiring
        row.dataset.slot = String(slot);
        row.setAttribute('draggable', 'true');
        row.addEventListener('dragstart', (ev) => {
          ev.dataTransfer.setData('text/plain', String(slot));
          ev.dataTransfer.effectAllowed = 'move';
        });
        row.addEventListener('dragover', (ev) => { ev.preventDefault(); row.classList.add('drop-target'); ev.dataTransfer.dropEffect = 'move'; });
        row.addEventListener('dragleave', () => row.classList.remove('drop-target'));
        row.addEventListener('drop', (ev) => {
          ev.preventDefault(); row.classList.remove('drop-target');
          const src = parseInt(ev.dataTransfer.getData('text/plain'), 10);
          const dst = parseInt(row.dataset.slot || '0', 10);
          reorderSlots(src, dst);
        });

        const left = document.createElement('div');
        left.style.flex = '1';
        left.style.minWidth = '0'; // Allow text truncation

        const name = document.createElement('div');
        name.className = 'name';
        name.style.display = 'flex';
        name.style.alignItems = 'center';
        name.style.gap = '8px';
        name.style.marginBottom = '4px';
        name.style.flexWrap = 'wrap';

        // Slot badge
        const badge = document.createElement('span');
        badge.className = 'slot-badge';
        badge.textContent = String(slot + 1).padStart(2, ' ');
        name.appendChild(badge);

        // Filename
        const label = document.createElement('span');
        label.style.overflow = 'hidden';
        label.style.textOverflow = 'ellipsis';
        label.style.whiteSpace = 'nowrap';
        label.style.flex = '0 1 auto';
        label.style.minWidth = '0';
        label.textContent = (s.entry.path ? s.entry.path + '/' : '') + s.entry.filename;
        name.appendChild(label);

        // Sample Name display (inline, always visible)
        if (s.sname && s.sname.trim()) {
          const snameDisplay = document.createElement('span');
          snameDisplay.style.fontSize = '11px';
          snameDisplay.style.padding = '2px 8px';
          snameDisplay.style.borderRadius = '10px';
          snameDisplay.style.background = '#f3f4f6';
          snameDisplay.style.color = '#374151';
          snameDisplay.style.fontWeight = '500';
          snameDisplay.style.whiteSpace = 'nowrap';
          snameDisplay.style.border = '1px solid #d1d5db';
          snameDisplay.textContent = s.sname;
          snameDisplay.title = 'Sample name (device)';
          name.appendChild(snameDisplay);
        }

        // Tags inline display (always visible)
        if (s.tags && s.tags.length > 0) {
          const tagsContainer = document.createElement('span');
          tagsContainer.style.display = 'inline-flex';
          tagsContainer.style.flexWrap = 'wrap';
          tagsContainer.style.gap = '4px';
          s.tags.forEach(tag => {
            const tagSpan = document.createElement('span');
            tagSpan.className = 'tag-mini';
            tagSpan.textContent = tag;
            tagsContainer.appendChild(tagSpan);
          });
          name.appendChild(tagsContainer);
        }

        const meta = document.createElement('div');
        meta.className = 'meta';
        meta.style.display = 'flex';
        meta.style.alignItems = 'center';
        meta.style.gap = '8px';
        meta.style.flexWrap = 'wrap';

        const bytesTxt = formatBytes(bytesForEntry(s.entry));
        const infoSpan = document.createElement('span');
        infoSpan.textContent = `nsamples: ${s.entry.nsamples} · ${bytesTxt}` + (s.entry.offset != null ? ` · offset: ${s.entry.offset}` : '');
        meta.appendChild(infoSpan);

        left.appendChild(name);
        left.appendChild(meta);

        const right = document.createElement('div');
        right.className = 'right-actions';
        right.style.display = 'flex';
        right.style.alignItems = 'center';
        right.style.gap = '6px';

        // Edit button (opens tag panel with both name and tags editable)
        const editBtn = document.createElement('button');
        editBtn.innerHTML = '✏️';
        editBtn.title = 'Edit sample name and tags (or right-click row)';
        editBtn.className = 'btn';
        editBtn.style.padding = '4px 10px';
        editBtn.style.fontSize = '16px';
        editBtn.style.lineHeight = '1';
        editBtn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          previewBlob(s.entry, s.file);
          const rect = editBtn.getBoundingClientRect();
          showTagPanel(rect.left - 320, rect.top, row);
        });
        right.appendChild(editBtn);
        // Remove button
        const rmBtn = document.createElement('button');
        rmBtn.textContent = 'Remove';
        rmBtn.className = 'btn';
        rmBtn.style.background = '#fee2e2';
        rmBtn.style.color = '#991b1b';
        rmBtn.style.border = '1px solid #fca5a5';
        rmBtn.addEventListener('click', (ev) => {
          ev.stopPropagation();
          removeFromBank(s.entry._idx);
        });
        right.appendChild(rmBtn);

        row.appendChild(left);
        row.appendChild(right);
        row.style.display = 'flex';
        row.style.gap = '12px';
        row.style.alignItems = 'flex-start';
        row.style.padding = '8px 6px';

        // Hover preview
        row.addEventListener('mouseenter', () => {
          if (autoPreviewEnabled) previewBlob(s.entry, s.file);
          row.style.background = '#f9fafb';
        });
        row.addEventListener('mouseleave', () => {
          stopPreview();
          hideTagPanel();
          row.style.background = '';
        });
        row.addEventListener('click', (e) => {
          // Don't trigger if clicking input or button
          if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
          previewBlob(s.entry, s.file);
        });

        // Right-click to show tag panel
        row.addEventListener('contextmenu', (ev) => {
          ev.preventDefault();
          previewBlob(s.entry, s.file);
          showTagPanel(ev.clientX, ev.clientY, row);
        });

        bankListEl.appendChild(row);
      });
    }

    function removeFromBank(idx) {
      const i = selection.findIndex((s) => s.entry._idx === idx);
      if (i >= 0) selection.splice(i, 1);
      renderLeftTree();
      renderRightTree();
      updateSelectionUI();
    }

    function addToBank(entry, file) {
      if (selection.length >= MAX_BANK) { alert('Bank is full (128 samples).'); return; }
      // Capacity check
      const bytesNeeded = entry.nsamples * BYTES_PER_SAMPLE;
      const used = totalUsedBytes();
      if (used + bytesNeeded > LIMIT_BYTES) {
        const over = used + bytesNeeded - LIMIT_BYTES;
        showWarning(`Cannot add: capacity exceeded by ${formatBytes(over)}.`);
        return;
      }
      if (selection.find((s) => s.entry._idx === entry._idx)) return;

      // Preserve tags if this file is currently selected
      const existingTags = (currentSelectedFile && currentSelectedFile.entry._idx === entry._idx)
        ? (currentSelectedFile.tags || [])
        : [];

      const selItem = { entry, file, sname: '', tags: existingTags };
      selection.push(selItem);
      // Generate and store 128-byte int8 preview asynchronously
      generatePreviewForFile(entry, file)
        .then((result) => {
          selItem.preview128 = Array.from(result.data);
          // If this item is currently shown in preview, redraw
          if (currentNameEl.textContent.endsWith(entry.filename)) {
            try {
              currentPreviewData = result.data;
              currentKeyPoints = result.keyPoints;
              currentSpectral = result.spectral;
              drawInt8Preview(lowResCanvas, result.data, null, result.keyPoints, result.spectral);
              updateAnalysisDisplay(result.analysis, result.keyPoints);
            } catch {}
          }
        })
        .catch(() => {/* ignore preview failure */});
      renderLeftTree(); // remove from left
      renderRightTree();
      updateSelectionUI();
    }

    function updateSelectionUI() {
      counter.textContent = `${selection.length}/128 selected`;
      clearBtn.disabled = selection.length === 0;
      exportBtn.disabled = selection.length === 0;
      saveBtn.disabled = selection.length === 0 || !FS_AVAILABLE;
      updateCapacity();
    }

    clearBtn.addEventListener('click', () => { selection = []; renderLeftTree(); renderRightTree(); updateSelectionUI(); });

    function totalUsedBytes() {
      return selection.reduce((acc, s) => acc + (s.entry.nsamples * BYTES_PER_SAMPLE), 0);
    }

    function updateCapacity() {
      const used = totalUsedBytes();
      const free = Math.max(0, LIMIT_BYTES - used);
      const secs = Math.floor(free / BYTES_PER_SECOND);
      const cls = used < LIMIT_BYTES * 0.9 ? 'cap-ok' : (used <= LIMIT_BYTES ? 'cap-warn' : 'cap-err');
      capacityInfo.className = `capacity ${cls}`;
      capacityInfo.textContent = `Used ${formatBytes(used)} · Free ${formatBytes(free)} (~${secs}s)`;
    }

    function formatBytes(n) {
      if (n >= 1024 * 1024) return (n / (1024 * 1024)).toFixed(2) + ' MiB';
      if (n >= 1024) return (n / 1024).toFixed(1) + ' KiB';
      return n + ' B';
    }

    async function previewBlob(entry, file) {
      currentNameEl.textContent = (entry.path ? entry.path + '/' : '') + entry.filename;
      durationEl.textContent = '--:--';

      // Set current file for tagging system
      // Check if this file is in selection
      const inSel = selection.find((s) => s.entry._idx === entry._idx);
      if (inSel) {
        currentSelectedFile = inSel;
      } else {
        // Create temporary object for files not yet in selection
        currentSelectedFile = { entry, file, tags: [], sname: '' };
      }
      updateTagDisplay();

      try {
        wavesurfer.empty();
        await wavesurfer.loadBlob(file);
        if (autoPreviewEnabled) {
          try { wavesurfer.play(0); } catch {}
        }
      } catch (e) {
        showWarning('Failed to preview: ' + (e?.message || e));
      }
      // Generate/draw low-res preview for the current file
      try {
        // If in selection and already computed, draw immediately
        if (inSel && inSel.preview128) {
          currentPreviewData = new Int8Array(inSel.preview128);
          currentKeyPoints = null; // Cached preview doesn't have key points
          currentSpectral = null;
          drawInt8Preview(lowResCanvas, currentPreviewData, null, null, null);
          if (analysisInfo) analysisInfo.textContent = '';
          if (peakLevel) peakLevel.textContent = '';
        } else {
          const result = await generatePreviewForFile(entry, file);
          currentPreviewData = result.data;
          currentKeyPoints = result.keyPoints;
          currentSpectral = result.spectral;
          drawInt8Preview(lowResCanvas, result.data, null, result.keyPoints, result.spectral);
          updateAnalysisDisplay(result.analysis, result.keyPoints);

          // Show peak level and size info
          if (peakLevel && result.peak) {
            const peakDB = 20 * Math.log10(result.peak / 32768);
            const peakPct = (result.peak / 32768 * 100).toFixed(1);
            const sizeKB = ((entry.nsamples * 2) / 1024).toFixed(1);

            let info = `Peak: ${peakPct}% (${peakDB.toFixed(1)}dB) • Size: ${sizeKB}KB`;

            // Add short percussive indicator
            if (result.isShortPercussive) {
              info += ' • [Short/Perc]';
            }

            // Add normalization indicator
            if (result.normalized) {
              info += ' • [Auto-normalized]';
            }

            // Add DC offset warning if significant
            if (result.dcOffset && Math.abs(result.dcOffset) > 500) {
              info += ` • DC: ${result.dcOffset > 0 ? '+' : ''}${Math.round(result.dcOffset)}`;
            }

            peakLevel.textContent = info;
          }
        }
      } catch {
        currentPreviewData = null;
        currentKeyPoints = null;
        currentSpectral = null;
        clearLowResCanvas();
        if (analysisInfo) analysisInfo.textContent = '';
        if (peakLevel) peakLevel.textContent = '';
      }
    }

    function stopPreview() {
      try {
        wavesurfer.pause();
        stopPlaybackIndicator();
        // Redraw without indicator but keep key points and spectral visible
        if (currentPreviewData) {
          drawInt8Preview(lowResCanvas, currentPreviewData, null, currentKeyPoints, currentSpectral);
        }
      } catch {}
    }

    // Export: JSN (no previews) + BIN (concatenated 128-byte int8 previews)
    async function ensureAllPreviews() {
      await Promise.all(selection.map(async (s) => {
        if (!s.preview128) {
          try {
            const result = await generatePreviewForFile(s.entry, s.file);
            s.preview128 = Array.from(result.data);
          } catch {/* ignore */}
        }
      }));
    }

    function buildSelectionJsonNoPreview() {
      const out = selection.map((s) => {
        // Start with core required fields
        const o = {
          filename: s.entry.filename,
          path: s.entry.path,
          nsamples: s.entry.nsamples
        };

        // Include all metadata from original wav_info_short.json entry
        // This preserves bpm, bars, and any other custom fields
        for (const key in s.entry) {
          // Skip internal fields and already-added fields
          if (key === '_idx' || key === 'filename' || key === 'path' || key === 'nsamples') {
            continue;
          }
          // Copy all other fields (offset, bpm, bars, etc.)
          o[key] = s.entry[key];
        }

        // Add user-defined metadata
        o.sname = (typeof s.sname === 'string') ? s.sname.slice(0, 8) : '';

        // Include tags if present
        if (s.tags && s.tags.length > 0) {
          o.tags = s.tags;
        }

        return o;
      });
      return JSON.stringify(out, null, 2);
    }

    function buildPreviewBin() {
      const count = selection.length;
      // 128 samples per preview, 2 samples per byte (4-bit each) = 64 bytes per preview
      const bytesPerPreview = 64;
      const bin = new Uint8Array(count * bytesPerPreview);

      for (let i = 0; i < count; i++) {
        const pv = selection[i].preview128 || [];
        const offset = i * bytesPerPreview;

        for (let j = 0; j < 128; j += 2) {
          // Preview data is already 0-15 range (4-bit)
          const v1 = (pv[j] != null ? pv[j] : 0);
          const v2 = (pv[j + 1] != null ? pv[j + 1] : 0);

          // Clamp values to 0-15 (should already be in range)
          const nibble1 = (v1 < 0 ? 0 : (v1 > 15 ? 15 : v1)) & 0x0F;
          const nibble2 = (v2 < 0 ? 0 : (v2 > 15 ? 15 : v2)) & 0x0F;

          // Pack: high nibble = first sample, low nibble = second sample
          bin[offset + (j >> 1)] = (nibble1 << 4) | nibble2;
        }
      }
      return bin;
    }

    exportBtn.addEventListener('click', async () => {
      await ensureAllPreviews();
      const json = buildSelectionJsonNoPreview();
      const bin = buildPreviewBin();
      const jsonBlob = new Blob([json], { type: 'application/json' });
      const binBlob = new Blob([bin.buffer], { type: 'application/octet-stream' });
      downloadBlob(jsonBlob, 'sample_bank.jsn');
      downloadBlob(binBlob, 'sample_bank_preview.bin');
    });

    // Save to folder (FS API)
    async function ensureDirHandle() {
      if (!FS_AVAILABLE) throw new Error('File System Access API not available in this context');
      if (!dirHandle) dirHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
      const perm = await dirHandle.queryPermission({ mode: 'readwrite' });
      if (perm !== 'granted') {
        const p2 = await dirHandle.requestPermission({ mode: 'readwrite' });
        if (p2 !== 'granted') throw new Error('Write permission denied for selected folder');
      }
      return dirHandle;
    }
    async function verifyTbdsamples(handle) { try { await handle.getFileHandle('wav_info_short.json'); return true; } catch { return false; } }
    saveBtn.addEventListener('click', async () => {
      if (!selection.length) return;
      try {
        await ensureAllPreviews();
        const handle = await ensureDirHandle();
        const isTbds = await verifyTbdsamples(handle);
        if (!isTbds) showWarning('Selected folder does not contain wav_info_short.json. Saving sample_bank.jsn anyway.');
        // Write JSN without previews
        const jsnHandle = await handle.getFileHandle('sample_bank.jsn', { create: true });
        const jsnWritable = await jsnHandle.createWritable();
        const json = buildSelectionJsonNoPreview();
        await jsnWritable.write(json);
        await jsnWritable.close();
        // Write BIN with concatenated 128-byte previews
        const binHandle = await handle.getFileHandle('sample_bank_preview.bin', { create: true });
        const binWritable = await binHandle.createWritable();
        const bin = buildPreviewBin();
        await binWritable.write(new Blob([bin.buffer], { type: 'application/octet-stream' }));
        await binWritable.close();
        summary.textContent = 'Saved sample_bank.jsn to selected folder';
      } catch (e) { showWarning('Failed to save to folder: ' + (e?.message || e)); }
    });

    // Load JSN handlers
    loadBtn.addEventListener('click', () => loadInput.click());
    loadInput.addEventListener('change', async () => {
      const file = loadInput.files && loadInput.files[0];
      if (!file) return;
      try {
        const text = await file.text();
        const data = JSON.parse(text);
        await loadBankFromJson(data);
      } catch (e) {
        showWarning('Failed to load bank JSN: ' + (e?.message || e));
      } finally {
        loadInput.value = '';
      }
    });

    async function loadBankFromJson(arr) {
      if (!Array.isArray(arr)) throw new Error('Bank JSN must be an array');
      if (!entries.length) throw new Error('Load a tbdsamples folder first');
      // Replace current bank
      selection = [];
      const usedIdx = new Set();
      let warnings = [];
      let usedBytes = 0;
      for (let i = 0; i < arr.length && selection.length < MAX_BANK; i++) {
        const it = arr[i] || {};
        const name = it.filename;
        const ns = it.nsamples;
        const off = Object.prototype.hasOwnProperty.call(it, 'offset') ? it.offset : undefined;

        // Support both legacy preview256 and new preview128 format
        let pv = null;
        if (Array.isArray(it.preview128) && it.preview128.length === 128) {
          pv = it.preview128.slice(0, 128);
        } else if (Array.isArray(it.preview256) && it.preview256.length === 256) {
          // Convert legacy 256 format to 128 by downsampling
          pv = new Array(128);
          for (let j = 0; j < 128; j++) {
            // Take max of two adjacent samples for downsampling
            const v1 = Math.abs(it.preview256[j * 2] || 0);
            const v2 = Math.abs(it.preview256[j * 2 + 1] || 0);
            const maxVal = Math.max(v1, v2);
            // Scale from 0-127 range to 0-15 range (4-bit)
            pv[j] = Math.min(15, Math.floor((maxVal / 127.0) * 15));
          }
        }

        const sname = (typeof it.sname === 'string') ? it.sname.slice(0, 8) : '';
        if (!name || typeof ns !== 'number') { warnings.push(`Item ${i}: missing filename/nsamples`); continue; }
        // Candidates by filename + nsamples (+offset if provided)
        let cands = entries.filter(e => e.filename === name && e.nsamples === ns);
        if (off !== undefined) cands = cands.filter(e => e.offset === off);
        // If still ambiguous, prefer not-yet-used
        let chosen = cands.find(e => !usedIdx.has(e._idx));
        // If still ambiguous or none, try filename only when unique
        if (!chosen) {
          const byName = entries.filter(e => e.filename === name);
          if (byName.length === 1) chosen = byName[0];
        }
        if (!chosen) { warnings.push(`Item ${i}: no unique match for "${name}"`); continue; }
        // Ensure file exists
        const key = ((chosen.path ? chosen.path + '/' : '') + chosen.filename).toLowerCase();
        const fileObj = wavMap.get(key);
        if (!fileObj) { warnings.push(`Item ${i}: file not found for ${key}`); continue; }
        // Capacity check
        const need = chosen.nsamples * BYTES_PER_SAMPLE;
        if (usedBytes + need > LIMIT_BYTES) { warnings.push(`Item ${i}: capacity exceeded, skipping`); continue; }

        // Restore tags if present in JSN
        const tags = Array.isArray(it.tags) ? it.tags : [];

        const selItem = { entry: chosen, file: fileObj, sname, tags };
        if (pv) selItem.preview128 = pv;
        selection.push(selItem);
        usedIdx.add(chosen._idx);
        usedBytes += need;
      }
      renderLeftTree();
      renderRightTree();
      updateSelectionUI();
      if (warnings.length) {
        showWarning(warnings.join('\n'));
      } else {
        warningsEl.style.display = 'none';
        warningsEl.textContent = '';
      }
    }

    // Helpers: size and color coding
    function bytesForEntry(e) { return (e.nsamples || 0) * BYTES_PER_SAMPLE; }
    function clamp01(x){ return Math.max(0, Math.min(1, x)); }
    function hsl(h, s, l){ return `hsl(${h} ${s}% ${l}%)`; }
    function applySizeColor(rowEl, bytes, freeBytes, isLeft) {
      // If left and file doesn't fit, hard red
      if (isLeft && bytes > freeBytes) {
        rowEl.style.backgroundColor = '#fee2e2'; // light red
        rowEl.style.border = '1px solid #ef4444';
        return;
      }
      const ratio = clamp01(bytes / LIMIT_BYTES);
      // Map 0->210 (blue) to 1->0 (red)
      const hue = Math.round((1 - ratio) * 210);
      rowEl.style.backgroundColor = hsl(hue, 85, 95);
      rowEl.style.border = '1px solid #e5e7eb';
    }

    function reorderSlots(src, dst) {
      if (isNaN(src) || isNaN(dst) || src === dst) return;
      const item = selection.splice(src, 1)[0];
      selection.splice(dst, 0, item);
      // Re-render right and update slot numbers, left unchanged
      renderRightTree();
      updateSelectionUI();
    }

    // Utils
    function downloadBlob(blob, name) { const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name; document.body.appendChild(a); a.click(); a.remove(); setTimeout(() => URL.revokeObjectURL(a.href), 0); }
    function showWarning(msg) { warningsEl.style.display = 'block'; warningsEl.textContent = msg; }
    function formatTime(sec) { if (!isFinite(sec)) return '--:--'; const m = Math.floor(sec / 60); const s = Math.floor(sec % 60); return `${m}:${s.toString().padStart(2, '0')}`; }

    // Low-res preview generation and rendering
    function updateAnalysisDisplay(analysis, keyPoints = null) {
      if (!analysisInfo) return;

      if (!analysis) {
        analysisInfo.textContent = '';
        analysisInfo.title = '';
        return;
      }

      // Show the selected algorithm and reason
      const displayText = analysis.algorithmReason || 'Hybrid';

      // Build emoji prefix based on characteristics
      let emoji = '🎚️'; // default
      if (analysis.hasTransients) emoji = '⚡';
      else if (analysis.hasAM) emoji = '〰️';
      else if (analysis.hasSpectralChange) emoji = '🌈';
      else if (analysis.isVeryQuiet) emoji = '🔇';
      else if (analysis.isDense) emoji = '🌊';
      else if (analysis.hasSilentSections) emoji = '🎵';

      analysisInfo.textContent = `${emoji} ${displayText}`;

      // Build detailed tooltip
      let tooltip = `Algorithm: ${analysis.selectedAlgorithm}\n`;
      tooltip += `Type: ${displayText}\n`;
      tooltip += `Crest Factor: ${analysis.crestFactor.toFixed(2)}\n`;

      // Add detected characteristics
      const characteristics = [];
      if (analysis.hasAM) {
        characteristics.push(`AM Modulation: ${(analysis.amStrength * 100).toFixed(0)}%`);
      }
      if (analysis.hasSpectralChange) {
        characteristics.push(`Spectral Change: ${(analysis.spectralChangeStrength * 100).toFixed(0)}%`);
      }
      if (analysis.hasTransients) {
        characteristics.push(`Transients: ${(analysis.transientStrength * 100).toFixed(0)}%`);
      }
      if (characteristics.length > 0) {
        tooltip += '\nCharacteristics:\n' + characteristics.join('\n');
      }

      // Add spectral character
      if (analysis.spectralHint) {
        tooltip += `\nSpectral: ${analysis.spectralHint}`;
      }

      analysisInfo.title = tooltip;
    }

    function clearLowResCanvas() {
      const ctx = lowResCanvas.getContext('2d');
      ctx.clearRect(0, 0, lowResCanvas.width, lowResCanvas.height);
    }

    async function generatePreviewForFile(entry, file) {
      const buf = await file.arrayBuffer();
      const offset = (entry && typeof entry.offset === 'number') ? entry.offset : 44;
      const nsamples = Math.max(0, entry?.nsamples | 0);

      // Generate downsampled preview data
      const previewResult = previewFromPcm16MonoBuffer(buf, offset, nsamples);

      return {
        data: previewResult.data,
        analysis: previewResult.analysis,
        keyPoints: null // Removed unreliable detection
      };
    }

    function previewFromPcm16MonoBuffer(buffer, offset, nsamples) {
      const dv = new DataView(buffer);
      const bytesPerSample = 2;
      const dataBytes = Math.max(0, dv.byteLength - offset);
      const maxSamplesFromFile = Math.floor(dataBytes / bytesPerSample);
      const total = Math.min(nsamples || maxSamplesFromFile, maxSamplesFromFile);

      // Output: 128 values (one per OLED horizontal pixel), 0-15 range (4-bit, 16 levels)
      const out = new Int8Array(128);
      if (total <= 0) {
        console.warn('Preview generation: total samples is 0 or negative:', total);
        return { data: out, analysis: null, peak: 0 };
      }

      // For very short samples, warn but continue
      if (total < 128) {
        console.warn('Preview generation: very short sample, total samples:', total);
      }

      // STEP 1: Calculate DC offset (average) to remove
      let dcSum = 0;
      const dcSampleCount = Math.min(4096, total); // Sample first 4096 for DC estimate
      for (let i = 0; i < dcSampleCount; i++) {
        const byteOff = offset + i * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        dcSum += dv.getInt16(byteOff, true);
      }
      const dcOffset = dcSum / dcSampleCount;

      // STEP 2: Analyze waveform characteristics
      const analysis = analyzeWaveform(dv, offset, total, bytesPerSample);

      // STEP 2.5: Detect short/sparse samples that need special handling
      // Includes: hi-hats, claps, short kicks, and any sample with concentrated energy
      const sampleDuration = total / 44100; // Assuming 44.1kHz
      const isShort = sampleDuration < 0.5; // Less than 500ms (increased from 300ms)
      const isPercussive = analysis.hasTransients && analysis.crestFactor > 6;

      // Also detect samples where energy is very concentrated (not necessarily percussive)
      const isSparse = analysis.silenceRatio > 0.6; // More than 60% silence

      // For short or sparse samples, find where the energy actually is
      let energyStartBlock = -1;
      let energyEndBlock = -1;
      let maxBlockRMS = 0;

      if ((isShort && isPercussive) || isSparse) {
        const BLOCKS = 128;
        const blockSize = total / BLOCKS;

        // First pass: find maximum RMS to set adaptive threshold
        for (let i = 0; i < BLOCKS; i++) {
          const startIdx = Math.floor(i * blockSize);
          const endIdx = Math.floor((i + 1) * blockSize);

          let sumSquares = 0;
          let count = 0;
          for (let j = startIdx; j < endIdx; j++) {
            const byteOff = offset + j * bytesPerSample;
            if (byteOff + 1 >= dv.byteLength) break;
            const v16 = Math.abs(dv.getInt16(byteOff, true) - dcOffset);
            sumSquares += v16 * v16;
            count++;
          }
          const rms = count > 0 ? Math.sqrt(sumSquares / count) : 0;
          if (rms > maxBlockRMS) maxBlockRMS = rms;
        }

        // Adaptive energy threshold: 15% of max RMS (catches quiet samples too)
        const energyThreshold = Math.max(200, maxBlockRMS * 0.15);

        // Second pass: find energy boundaries
        for (let i = 0; i < BLOCKS; i++) {
          const startIdx = Math.floor(i * blockSize);
          const endIdx = Math.floor((i + 1) * blockSize);

          let sumSquares = 0;
          let count = 0;
          for (let j = startIdx; j < endIdx; j++) {
            const byteOff = offset + j * bytesPerSample;
            if (byteOff + 1 >= dv.byteLength) break;
            const v16 = Math.abs(dv.getInt16(byteOff, true) - dcOffset);
            sumSquares += v16 * v16;
            count++;
          }
          const rms = count > 0 ? Math.sqrt(sumSquares / count) : 0;

          if (rms > energyThreshold) {
            if (energyStartBlock === -1) energyStartBlock = i;
            energyEndBlock = i;
          }
        }
      }

      // STEP 3: Find true peak for optional normalization
      let globalPeak = 0;
      for (let i = 0; i < total; i += 128) { // Sample every 128 samples for speed
        const byteOff = offset + i * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        const v16 = Math.abs(dv.getInt16(byteOff, true) - dcOffset);
        if (v16 > globalPeak) globalPeak = v16;
      }

      // Decide if normalization would help (if peak < 50% of full scale)
      const shouldNormalize = globalPeak < 16384 && !analysis.isVeryQuiet;
      const normalizationFactor = shouldNormalize ? (28000 / globalPeak) : 1.0;

      // STEP 4: Generate preview using intelligent algorithm selection
      const BLOCKS = 128;
      const blockSize = Math.max(1, total / BLOCKS); // Ensure minimum 1 sample per block

      // Accumulate spectral data for overall visualization
      let totalBass = 0, totalMid = 0, totalTreble = 0;
      let spectralBlocks = 0;

      // Track spectral changes across blocks for spectral-weighted algorithm
      const spectralData = [];
      let prevZCRate = 0;

      // FIRST PASS: Collect spectral data for all blocks
      let totalPerceptBrightness = 0;
      for (let i = 0; i < BLOCKS; i++) {
        const startIdx = Math.floor(i * blockSize);
        const endIdx = Math.min(total, Math.floor((i + 1) * blockSize)); // Clamp to total

        // Skip if no samples in this block (for very short samples)
        if (startIdx >= endIdx) {
          spectralData.push({ bass: 0, mid: 0, treble: 0, brightness: 0, perceptualBrightness: 0, zcRate: 0 });
          continue;
        }

        const spectral = analyzeSpectralContent(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset);
        spectralData.push(spectral);

        totalBass += spectral.bass;
        totalMid += spectral.mid;
        totalTreble += spectral.treble;
        totalPerceptBrightness += spectral.perceptualBrightness;
        spectralBlocks++;
      }

      // Calculate average spectral characteristics for normalization
      const avgPerceptBrightness = spectralBlocks > 0 ? totalPerceptBrightness / spectralBlocks : 0.5;

      // Calculate spectral normalization factor based on average brightness
      // Bright samples (avgPerceptBrightness > 0.6): reduce modulation (factor < 1.0)
      // Dark samples (avgPerceptBrightness < 0.4): increase modulation (factor > 1.0)
      // This compresses bright samples and expands dark samples for balanced visualization
      const spectralNormalizationFactor = 0.5 + (1.0 - avgPerceptBrightness) * 0.8; // Range: 0.18 to 0.98

      // SECOND PASS: Generate preview values with context awareness
      for (let i = 0; i < BLOCKS; i++) {
        const startIdx = Math.floor(i * blockSize);
        const endIdx = Math.min(total, Math.floor((i + 1) * blockSize)); // Clamp to total

        let value = 0;

        // Skip empty blocks (for very short samples)
        if (startIdx >= endIdx) {
          out[i] = 0;
          continue;
        }

        const spectral = spectralData[i];
        const peak = computeBlockPeakDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset);
        const rms = computeBlockRMSDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset);

        // SPECIAL CASE: Short/sparse samples with concentrated energy
        // Stretch the active portion to make it visible across more blocks
        if (((isShort && isPercussive) || isSparse) && energyStartBlock !== -1 && energyEndBlock !== -1) {
          const activeBlocks = energyEndBlock - energyStartBlock + 1;

          if (activeBlocks < 60 && activeBlocks > 0) { // Energy concentrated in less than half the blocks
            // Map current block to stretched range
            const stretchFactor = 60 / activeBlocks; // Stretch to at least 60 blocks
            const stretchedBlock = energyStartBlock + Math.floor((i - energyStartBlock) / stretchFactor);

            if (i >= energyStartBlock && i < energyStartBlock + 60 && stretchedBlock <= energyEndBlock) {
              // Use the stretched block's data
              const stretchedStartIdx = Math.floor(stretchedBlock * blockSize);
              const stretchedEndIdx = Math.min(total, Math.floor((stretchedBlock + 1) * blockSize));

              if (stretchedStartIdx < stretchedEndIdx) {
                const stretchedPeak = computeBlockPeakDC(dv, offset, stretchedStartIdx, stretchedEndIdx, bytesPerSample, dcOffset);
                const stretchedRMS = computeBlockRMSDC(dv, offset, stretchedStartIdx, stretchedEndIdx, bytesPerSample, dcOffset);

                // Use peak-dominant rendering for percussive sounds
                value = stretchedPeak * 0.9 + stretchedRMS * 0.1;

                // Apply brightness tint
                const stretchedSpectral = spectralData[stretchedBlock];
                value = value * (0.85 + stretchedSpectral.brightness * 0.15);
              } else {
                value = peak * (0.85 + spectral.brightness * 0.15);
              }
            } else {
              // Outside the stretched range - show minimal tail/silence
              value = peak * 0.2; // Very quiet tail
            }
          } else {
            // Active portion is already spread enough, use normal peak rendering
            value = peak * (0.85 + spectral.brightness * 0.15);
          }
        }
        // FALLBACK: If short/sparse but energy detection failed, use simple peak rendering
        else if ((isShort && isPercussive) || isSparse) {
          // Energy detection failed - just render what we have
          value = peak * (0.9 + spectral.brightness * 0.1);
        }
        // OVERRIDE: Short/sparse samples should use peak rendering, not complex algorithms
        // Complex algorithms like hybrid-dynamic don't work well with sparse data
        else if ((isShort || isSparse) && (analysis.selectedAlgorithm === 'hybrid-dynamic' ||
                                            analysis.selectedAlgorithm === 'spectral-weighted' ||
                                            analysis.selectedAlgorithm === 'rms-am')) {
          // For short/sparse samples, use simple peak-dominant rendering
          value = peak * (0.85 + spectral.brightness * 0.15);
        }
        // INTELLIGENT ALGORITHM SELECTION based on detected characteristics
        else switch (analysis.selectedAlgorithm) {
          case 'peak':
            // Pure peak for transient-heavy (drums, percussion)
            value = peak * (0.85 + spectral.brightness * 0.15);
            break;

          case 'rms-am':
            // RMS optimized for AM-modulated sounds (tremolo, auto-pan, LFO amplitude)
            // Show the envelope shape clearly
            value = rms * (1.0 + spectral.mid * 0.1);
            break;

          case 'spectral-weighted':
            // For sounds with spectral variation but stable amplitude (filter sweeps, FM)
            // Calculate PERCEPTUAL spectral change with noise filtering
            let spectralChange = 0;
            let hasSignificantChange = false;

            if (i > 0) {
              // Use weighted combination with THRESHOLDING to filter noise
              let totalChange = 0;
              let totalWeight = 0;

              // Define minimum thresholds for each metric (filters out noise/jitter)
              const BRIGHTNESS_THRESHOLD = 0.08;  // 8% change minimum
              const BAND_THRESHOLD = 0.05;        // 5% change minimum
              const ZC_THRESHOLD = 0.02;          // 2% change minimum

              // Look at changes over last 3 blocks for smoother curve
              for (let lookback = 1; lookback <= Math.min(3, i); lookback++) {
                const prevSpectral = spectralData[i - lookback];

                // Calculate individual changes with thresholding
                const zcChange = Math.abs(spectral.zcRate - prevSpectral.zcRate);
                const perceptBrightChange = Math.abs(
                  spectral.perceptualBrightness - prevSpectral.perceptualBrightness
                );
                const midChange = Math.abs(spectral.mid - prevSpectral.mid);
                const bassChange = Math.abs(spectral.bass - prevSpectral.bass);
                const trebleChange = Math.abs(spectral.treble - prevSpectral.treble);

                // Apply thresholds - only count if above noise floor
                const filteredBrightChange = perceptBrightChange > BRIGHTNESS_THRESHOLD ?
                  (perceptBrightChange - BRIGHTNESS_THRESHOLD) : 0;
                const filteredMidChange = midChange > BAND_THRESHOLD ?
                  (midChange - BAND_THRESHOLD) : 0;
                const filteredZCChange = zcChange > ZC_THRESHOLD ?
                  (zcChange - ZC_THRESHOLD) : 0;
                const filteredBassChange = bassChange > BAND_THRESHOLD ?
                  (bassChange - BAND_THRESHOLD) : 0;
                const filteredTrebleChange = trebleChange > BAND_THRESHOLD ?
                  (trebleChange - BAND_THRESHOLD) : 0;

                // Weight by perceptual importance (more moderate multipliers)
                const weightedChange =
                  filteredBrightChange * 1.4 +  // Most important
                  filteredMidChange * 1.0 +     // Important
                  filteredZCChange * 0.8 +      // Moderately important
                  filteredTrebleChange * 0.7 +  // Less important
                  filteredBassChange * 0.4;     // Least important

                // Check if this lookback has significant change
                if (weightedChange > 0.05) hasSignificantChange = true;

                // Recent changes weighted more
                const timeWeight = 1.0 / lookback;
                totalChange += weightedChange * timeWeight;
                totalWeight += timeWeight;
              }

              spectralChange = totalWeight > 0 ? totalChange / totalWeight : 0;
            }

            // Base value
            const baseValue = rms * 0.5 + peak * 0.5;

            // Only apply spectral modulation if there are SIGNIFICANT changes
            let spectralModulation;
            if (hasSignificantChange && spectralChange > 0.03) {
              // Moderate normalization (reduced from 8 to 6 for stability)
              const normalizedChange = Math.min(1, spectralChange * 6);

              // Moderate power curve
              const changeBoost = Math.pow(normalizedChange, 0.8);

              // MINIMAL baseline - only slight tint based on brightness (max 0.15)
              const spectralBaseline = Math.min(0.15, spectral.perceptualBrightness * 0.15);

              // Dynamic modulation based on changes: 0.8x to 1.6x range (further reduced)
              const dynamicMod = changeBoost * 0.8;

              // Apply normalization factor to compress bright samples
              const normalizedDynamicMod = dynamicMod * spectralNormalizationFactor;

              // Combine: baseline (0.8) + dynamic component + minimal spectral baseline
              spectralModulation = 0.8 + normalizedDynamicMod + spectralBaseline;
            } else {
              // No significant changes - use pure RMS-based rendering
              // Absolutely minimal spectral influence (max 0.08)
              const spectralTint = spectral.perceptualBrightness * 0.08;
              spectralModulation = 0.95 + spectralTint; // Very stable: 0.95-1.03 range
            }

            // Clamp final modulation to tighter safe range
            const clampedModulation = Math.max(0.6, Math.min(1.6, spectralModulation));
            value = baseValue * clampedModulation;
            break;

          case 'hybrid-dynamic':
            // Both AM and spectral changes (complex evolving sounds)
            // Track spectral change just like spectral-weighted
            let dynSpectralChange = 0;
            if (i > 0) {
              const prevSpectral = spectralData[i - 1];
              dynSpectralChange = Math.abs(spectral.zcRate - prevSpectral.zcRate);
              const brightnessChange = Math.abs(spectral.brightness - prevSpectral.brightness);
              dynSpectralChange = Math.max(dynSpectralChange, brightnessChange);
            }
            const dynNormalizedChange = Math.min(1, dynSpectralChange * 5);

            // Balance between showing envelope (AM) and spectral content
            const dynamicRMS = rms * (0.7 + analysis.amStrength * 0.5);
            const dynamicPeak = peak * (0.7 + dynNormalizedChange * 0.6 + spectral.brightness * 0.3);
            value = dynamicRMS * 0.4 + dynamicPeak * 0.6;
            break;

          case 'rms-dense':
            // Dense sustained material (pads, drones, noise)
            const rmsWeight = 0.7 + (spectral.bass * 0.15);
            const peakWeight = 0.3 + (spectral.treble * 0.15);
            value = rms * rmsWeight + peak * peakWeight;
            break;

          case 'rms-boost':
            // Quiet material - boost RMS, emphasize mids
            value = Math.min(32767, rms * 2.5 * (0.9 + spectral.mid * 0.2));
            break;

          case 'peak-gaps':
            // Gapped material - preserve attacks
            value = peak * (0.9 + spectral.brightness * 0.1);
            break;

          case 'hybrid':
          default:
            // Default hybrid - balanced approach
            const hybridRMS = 0.75 + (spectral.bass - spectral.treble) * 0.1;
            const hybridPeak = 0.25 + (spectral.treble - spectral.bass) * 0.1;
            value = rms * Math.max(0.6, Math.min(0.85, hybridRMS)) +
                    peak * Math.max(0.15, Math.min(0.4, hybridPeak));
            break;
        }

        // Apply normalization if needed
        value = Math.min(32767, value * normalizationFactor);

        // Convert to 0-15 range with PERCEPTUAL curve (4-bit quantization)
        const normalized = value / 32768.0;
        // Adaptive curve power based on spectral brightness and algorithm
        let curvePower = 0.75;

        // Special handling for short/sparse samples
        if ((isShort && isPercussive) || isSparse) {
          // Use sharper curve to show peak detail
          curvePower = 0.65;
        } else if (analysis.selectedAlgorithm === 'spectral-weighted') {
          // Moderate curve for spectral changes - balanced between visibility and stability
          // Use perceptual brightness for more human-like response
          const perceptBright = spectralData[i].perceptualBrightness || 0.5;
          curvePower = 0.62 + (perceptBright * 0.15); // 0.62-0.77 range (more moderate)
        } else if (analysis.selectedAlgorithm === 'rms-am') {
          // Gentler curve for AM to show smooth envelope
          curvePower = 0.8;
        } else {
          // Default adaptive - use perceptual brightness if available
          const brightVal = spectralData[i].perceptualBrightness || spectral.brightness || 0.5;
          curvePower = 0.75 + (brightVal - 0.5) * 0.05;
        }
        const compressed = Math.pow(normalized, curvePower);
        const u8 = Math.min(15, Math.floor(compressed * 15.5)); // 4-bit: 0-15

        out[i] = u8;
      }

      // Calculate average spectral content for visualization
      const avgSpectral = spectralBlocks > 0 ? {
        bass: totalBass / spectralBlocks,
        mid: totalMid / spectralBlocks,
        treble: totalTreble / spectralBlocks
      } : null;

      return {
        data: out,
        analysis: analysis,
        peak: globalPeak,
        normalized: shouldNormalize,
        dcOffset: Math.abs(dcOffset) > 100 ? dcOffset : 0,
        spectral: avgSpectral,
        isShortPercussive: (isShort && isPercussive) || isSparse
      };
    }

    // DC-corrected peak calculation
    function computeBlockPeakDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset) {
      let peakAbs = 0;
      for (let j = startIdx; j < endIdx; j++) {
        const byteOff = offset + j * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        const v16 = Math.abs(dv.getInt16(byteOff, true) - dcOffset);
        if (v16 > peakAbs) peakAbs = v16;
      }
      return peakAbs;
    }

    // DC-corrected RMS calculation
    function computeBlockRMSDC(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset) {
      let sumSquares = 0;
      let count = 0;
      for (let j = startIdx; j < endIdx; j++) {
        const byteOff = offset + j * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        const v16 = dv.getInt16(byteOff, true) - dcOffset;
        const abs = Math.abs(v16);
        sumSquares += abs * abs;
        count++;
      }
      return count > 0 ? Math.sqrt(sumSquares / count) : 0;
    }

    // Perceptually-weighted spectral analysis based on human hearing
    // Uses A-weighting principles and logarithmic frequency perception
    function analyzeSpectralContent(dv, offset, startIdx, endIdx, bytesPerSample, dcOffset) {
      const blockSize = endIdx - startIdx;
      if (blockSize < 64) return { bass: 0, mid: 0, treble: 0, brightness: 0, perceptualBrightness: 0 };

      // Human hearing perception (A-weighting inspired):
      // - Sub-bass (< 60Hz): -20dB relative sensitivity
      // - Bass (60-250Hz): -10dB
      // - Low-mid (250-500Hz): -3dB
      // - Mid (500-2kHz): 0dB (most sensitive)
      // - Upper-mid (2k-5kHz): +3dB (MOST sensitive, speech/presence)
      // - Treble (5k-10kHz): 0dB
      // - High treble (10k+): -10dB

      let zeroCrossings = 0;
      let totalEnergy = 0;

      // Perceptually-weighted energy bins
      let subBassEnergy = 0;     // Very low freq (ZC: 0-0.03)
      let bassEnergy = 0;        // Low freq (ZC: 0.03-0.08)
      let lowMidEnergy = 0;      // Low-mid (ZC: 0.08-0.12)
      let midEnergy = 0;         // Mid (ZC: 0.12-0.20) - ear most sensitive
      let upperMidEnergy = 0;    // Upper-mid (ZC: 0.20-0.30) - VERY sensitive
      let trebleEnergy = 0;      // Treble (ZC: 0.30-0.45)
      let highTrebleEnergy = 0;  // High treble (ZC: 0.45+)

      // Use smaller windows for better frequency resolution
      const windowSize = Math.min(64, Math.floor(blockSize / 4));

      for (let i = 0; i < 4 && (startIdx + i * windowSize) < endIdx; i++) {
        const winStart = startIdx + i * windowSize;
        const winEnd = Math.min(winStart + windowSize, endIdx);

        let winZeroCross = 0;
        let winEnergy = 0;
        let prevSample = 0;

        for (let j = winStart; j < winEnd; j++) {
          const byteOff = offset + j * bytesPerSample;
          if (byteOff + 1 >= dv.byteLength) break;

          const sample = dv.getInt16(byteOff, true) - dcOffset;
          const absSample = Math.abs(sample);

          // Count zero crossings
          if (j > winStart) {
            if ((prevSample >= 0 && sample < 0) || (prevSample < 0 && sample >= 0)) {
              winZeroCross++;
            }
          }

          winEnergy += absSample * absSample;
          prevSample = sample;
        }

        const zcRate = winZeroCross / windowSize;

        // Bin energy into perceptual frequency bands
        if (zcRate < 0.03) {
          subBassEnergy += winEnergy * 0.1; // De-emphasize (humans barely hear this)
        } else if (zcRate < 0.08) {
          bassEnergy += winEnergy * 0.32; // Reduced sensitivity
        } else if (zcRate < 0.12) {
          lowMidEnergy += winEnergy * 0.5; // Moderate
        } else if (zcRate < 0.20) {
          midEnergy += winEnergy * 1.0; // Full sensitivity
        } else if (zcRate < 0.30) {
          upperMidEnergy += winEnergy * 1.41; // BOOST (speech/presence, humans very sensitive)
        } else if (zcRate < 0.45) {
          trebleEnergy += winEnergy * 1.0; // Full sensitivity
        } else {
          highTrebleEnergy += winEnergy * 0.32; // De-emphasize extreme highs
        }

        totalEnergy += winEnergy;
        zeroCrossings += winZeroCross;
      }

      // Calculate average zero-crossing rate
      const avgZCRate = zeroCrossings / blockSize;

      // Calculate perceptually-weighted total
      const perceptualTotal = subBassEnergy + bassEnergy + lowMidEnergy +
                              midEnergy + upperMidEnergy + trebleEnergy + highTrebleEnergy;

      // Normalize to 0-1 range for each band with safety check
      const normFactor = perceptualTotal > 0 ? 1.0 / perceptualTotal : 0;

      // Combine into traditional bass/mid/treble for compatibility
      // But now perceptually weighted! Add clamping for safety
      const bass = Math.min(1.0, (subBassEnergy + bassEnergy) * normFactor);
      const mid = Math.min(1.0, (lowMidEnergy + midEnergy + upperMidEnergy) * normFactor);
      const treble = Math.min(1.0, (trebleEnergy + highTrebleEnergy) * normFactor);

      // Perceptual brightness: weight by human hearing sensitivity
      // Upper-mid has strongest influence (speech/presence range)
      // Clamp to 0-1 range for stability
      const perceptualBrightness = perceptualTotal > 0 ?
        Math.max(0, Math.min(1.0,
          (upperMidEnergy * 1.8 + trebleEnergy * 1.3 + midEnergy * 0.7) / (perceptualTotal * 1.8)
        )) : 0.5;

      // Standard brightness (for compatibility), also clamped
      const brightness = totalEnergy > 0 ?
        Math.max(0, Math.min(1.0,
          (upperMidEnergy + trebleEnergy + highTrebleEnergy) / totalEnergy
        )) : 0.5;

      return {
        bass,
        mid,
        treble,
        brightness,
        perceptualBrightness,
        zcRate: avgZCRate
      };
    }


    function analyzeWaveform(dv, offset, total, bytesPerSample) {
      // Advanced analysis: detect AM, FM/spectral changes, and transients
      // Sample at multiple points throughout the file for better coverage
      const numWindows = 16; // Analyze 16 windows across the sample
      const windowSize = Math.min(2048, Math.floor(total / numWindows));

      let sumAbs = 0;
      let sumSquares = 0;
      let maxPeak = 0;
      let silentSamples = 0;
      let transientCount = 0;
      let zeroCrossings = 0;

      // Arrays to track changes over time
      const windowEnergies = [];
      const windowZCRates = [];
      const windowPeaks = [];

      let prevAbs = 0;
      let prevSample = 0;

      const silenceThreshold = 100;
      const transientThreshold = 8000;

      // Analyze multiple windows across the sample
      for (let w = 0; w < numWindows; w++) {
        const windowStart = Math.floor((w / numWindows) * total);
        const windowEnd = Math.min(windowStart + windowSize, total);

        let winEnergy = 0;
        let winZC = 0;
        let winPeak = 0;
        let winSamples = 0;
        let winPrevSample = 0;

        for (let i = windowStart; i < windowEnd; i++) {
          const byteOff = offset + i * bytesPerSample;
          if (byteOff + 1 >= dv.byteLength) break;

          const v16 = dv.getInt16(byteOff, true);
          const abs = Math.abs(v16);

          sumAbs += abs;
          sumSquares += abs * abs;
          if (abs > maxPeak) maxPeak = abs;
          if (abs < silenceThreshold) silentSamples++;

          // Window-specific stats
          winEnergy += abs * abs;
          if (abs > winPeak) winPeak = abs;
          winSamples++;

          // Detect transients
          if (Math.abs(abs - prevAbs) > transientThreshold) transientCount++;

          // Count zero crossings
          if (i > windowStart) {
            if ((winPrevSample >= 0 && v16 < 0) || (winPrevSample < 0 && v16 >= 0)) {
              winZC++;
              zeroCrossings++;
            }
          }

          prevAbs = abs;
          prevSample = v16;
          winPrevSample = v16;
        }

        if (winSamples > 0) {
          windowEnergies.push(Math.sqrt(winEnergy / winSamples));
          windowZCRates.push(winZC / winSamples);
          windowPeaks.push(winPeak);
        }
      }

      const totalSamples = numWindows * windowSize;
      const avgAbs = sumAbs / totalSamples;
      const rms = Math.sqrt(sumSquares / totalSamples);
      const crestFactor = maxPeak / (rms + 1);
      const silenceRatio = silentSamples / totalSamples;
      const transientDensity = transientCount / totalSamples;
      const avgZCRate = zeroCrossings / totalSamples;

      // AMPLITUDE MODULATION (AM) DETECTION
      // Calculate variance in energy across windows
      const avgEnergy = windowEnergies.reduce((a, b) => a + b, 0) / windowEnergies.length;
      const energyVariance = windowEnergies.reduce((sum, e) => sum + Math.pow(e - avgEnergy, 2), 0) / windowEnergies.length;
      const energyStdDev = Math.sqrt(energyVariance);
      const energyCV = avgEnergy > 0 ? energyStdDev / avgEnergy : 0; // Coefficient of variation

      // High CV = significant amplitude modulation
      const hasAM = energyCV > 0.3; // >30% variation
      const amStrength = Math.min(1, energyCV / 0.6); // 0-1 scale

      // FREQUENCY MODULATION (FM) / SPECTRAL VARIATION DETECTION
      // Calculate variance in zero-crossing rate across windows
      const avgZC = windowZCRates.reduce((a, b) => a + b, 0) / windowZCRates.length;
      const zcVariance = windowZCRates.reduce((sum, zc) => sum + Math.pow(zc - avgZC, 2), 0) / windowZCRates.length;
      const zcStdDev = Math.sqrt(zcVariance);
      const zcCV = avgZC > 0 ? zcStdDev / avgZC : 0;

      // High ZC variation = spectral changes (FM, filters, etc.)
      const hasSpectralChange = zcCV > 0.15; // >15% variation (was 25%, now more sensitive)
      const spectralChangeStrength = Math.min(1, zcCV / 0.4); // Scale to 1.0 at 40% CV

      // TRANSIENT CHARACTERISTICS
      // Calculate variance in peaks across windows
      const avgPeak = windowPeaks.reduce((a, b) => a + b, 0) / windowPeaks.length;
      const peakVariance = windowPeaks.reduce((sum, p) => sum + Math.pow(p - avgPeak, 2), 0) / windowPeaks.length;
      const peakStdDev = Math.sqrt(peakVariance);
      const peakCV = avgPeak > 0 ? peakStdDev / avgPeak : 0;

      const hasTransients = crestFactor > 6 && transientDensity > 0.03;
      const transientStrength = Math.min(1, crestFactor / 12);

      // INTELLIGENT ALGORITHM SELECTION
      let selectedAlgorithm = 'hybrid'; // default
      let algorithmReason = '';

      if (hasTransients && transientStrength > 0.6) {
        selectedAlgorithm = 'peak'; // Pure peak for drums, clicks
        algorithmReason = 'Transient-heavy';
      } else if (hasSpectralChange && spectralChangeStrength > 0.3) {
        // PRIORITIZE spectral changes - even with some AM
        if (hasAM && amStrength > 0.4) {
          selectedAlgorithm = 'hybrid-dynamic'; // Both AM and FM
          algorithmReason = 'AM+Spectral';
        } else {
          selectedAlgorithm = 'spectral-weighted'; // Spectral changes emphasized
          algorithmReason = 'Spectral-varying';
        }
      } else if (hasAM && amStrength > 0.5) {
        selectedAlgorithm = 'rms-am'; // RMS optimized for AM
        algorithmReason = 'AM-modulated';
      } else if (crestFactor < 3 && silenceRatio < 0.1) {
        selectedAlgorithm = 'rms-dense'; // Dense material
        algorithmReason = 'Dense/Sustained';
      } else if (avgAbs < 2000) {
        selectedAlgorithm = 'rms-boost'; // Quiet material
        algorithmReason = 'Quiet';
      } else if (silenceRatio > 0.3) {
        selectedAlgorithm = 'peak-gaps'; // Gapped material
        algorithmReason = 'Gapped';
      }

      // Spectral hint
      let spectralHint = '';
      if (avgZCRate < 0.05) {
        spectralHint = 'Bass-heavy / Dark';
      } else if (avgZCRate < 0.15) {
        spectralHint = 'Mid-range balanced';
      } else {
        spectralHint = 'Bright / High-freq';
      }

      return {
        // Legacy compatibility
        isTransientHeavy: hasTransients,
        isVeryQuiet: avgAbs < 2000,
        isDense: crestFactor < 3 && silenceRatio < 0.1,
        hasSilentSections: silenceRatio > 0.3,
        crestFactor: crestFactor,
        avgLevel: avgAbs,
        spectralHint: spectralHint,

        // New detailed analysis
        hasAM: hasAM,
        amStrength: amStrength,
        hasSpectralChange: hasSpectralChange,
        spectralChangeStrength: spectralChangeStrength,
        hasTransients: hasTransients,
        transientStrength: transientStrength,
        selectedAlgorithm: selectedAlgorithm,
        algorithmReason: algorithmReason,

        // Detailed metrics for adaptive processing
        energyCV: energyCV,
        zcCV: zcCV,
        peakCV: peakCV,
        windowEnergies: windowEnergies, // For adaptive RMS weighting
        windowZCRates: windowZCRates    // For adaptive spectral weighting
      };
    }

    function computeBlockPeak(dv, offset, startIdx, endIdx, bytesPerSample) {
      let peakAbs = 0;
      for (let j = startIdx; j < endIdx; j++) {
        const byteOff = offset + j * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        const v16 = dv.getInt16(byteOff, true);
        const abs = Math.abs(v16);
        if (abs > peakAbs) peakAbs = abs;
      }
      return peakAbs;
    }

    function computeBlockRMS(dv, offset, startIdx, endIdx, bytesPerSample) {
      let sumSquares = 0;
      let count = 0;
      for (let j = startIdx; j < endIdx; j++) {
        const byteOff = offset + j * bytesPerSample;
        if (byteOff + 1 >= dv.byteLength) break;
        const v16 = dv.getInt16(byteOff, true);
        const abs = Math.abs(v16);
        sumSquares += abs * abs;
        count++;
      }
      return count > 0 ? Math.sqrt(sumSquares / count) : 0;
    }

    function drawInt8Preview(canvas, data, playbackPosition = null, keyPoints = null, spectralData = null) {
      const ctx = canvas.getContext('2d');
      const w = 128; // OLED width
      const h = 64;  // OLED height

      // Clear entire display to black (OLED off state)
      ctx.fillStyle = '#000000';
      ctx.fillRect(0, 0, w, h);

      // Draw sample info text at top (rows 0-18)
      if (currentNameEl && currentNameEl.textContent !== 'Nothing selected') {
        const filename = currentNameEl.textContent.split('/').pop();
        const duration = durationEl ? durationEl.textContent : '--:--';

        ctx.fillStyle = '#FFFFFF';
        ctx.font = '8px monospace';

        // Truncate filename if too long
        let displayName = filename;
        if (displayName.length > 18) {
          displayName = displayName.substring(0, 15) + '...';
        }

        // Draw filename at top
        ctx.fillText(displayName, 2, 8);

        // Draw duration and sample rate info
        ctx.font = '7px monospace';
        ctx.fillText(`${duration} | 44.1k`, 2, 18);
      }

      // Draw spectral content visualization (rows 22-36) if available
      if (spectralData) {
        const spectralY = 22;
        const spectralHeight = 14;
        const barHeight = 3;
        const maxBarWidth = 100;

        // Draw mini spectrum bars
        const bars = [
          { label: 'B', value: spectralData.bass, y: spectralY },
          { label: 'M', value: spectralData.mid, y: spectralY + 5 },
          { label: 'T', value: spectralData.treble, y: spectralY + 10 }
        ];

        ctx.fillStyle = '#FFFFFF';
        ctx.font = '7px monospace';

        bars.forEach(bar => {
          // Draw label
          ctx.fillText(bar.label, 2, bar.y + 2);

          // Draw bar
          const barWidth = Math.floor(bar.value * maxBarWidth);
          if (barWidth > 0) {
            ctx.fillRect(12, bar.y - 1, barWidth, barHeight);
          }
        });
      }

      // Waveform preview occupies bottom third (24 pixels): rows 40-63
      const PREVIEW_START_Y = 40; // Start at pixel row 40
      const PREVIEW_HEIGHT = 24;  // 24 pixels tall
      const SAMPLES = 128;

      // For OLED emulation, we'll draw with a slight glow effect
      const imageData = ctx.createImageData(w, h);
      const pixels = imageData.data;

      // Draw waveform in bottom section with optional smoothing
      for (let x = 0; x < SAMPLES; x++) {
        const val = (data && data[x] != null) ? data[x] : 0; // 0-15 (4-bit)

        // Use native 4-bit values (0-15) without scaling
        // This shows true quantization levels matching the export format
        const displayVal = Math.min(val, 15); // Clamp to 0-15

        if (displayVal > 0) {
          // Draw vertical bar from bottom up
          for (let y = 0; y < displayVal && y < PREVIEW_HEIGHT; y++) {
            const pixelY = h - 1 - y; // Start from bottom (row 63)
            const index = (pixelY * w + x) * 4;

            // Determine brightness with better gradient
            // Brighter at bottom, dimmer at top for depth perception
            const heightRatio = y / PREVIEW_HEIGHT;
            const brightness = 255 - (heightRatio * 80); // 255 at bottom to 175 at top

            pixels[index] = brightness;     // R
            pixels[index + 1] = brightness; // G
            pixels[index + 2] = brightness; // B
            pixels[index + 3] = 255;        // A
          }

          // Add subtle anti-aliasing at the tip for smoother appearance
          if (displayVal < PREVIEW_HEIGHT - 1) {
            const tipY = h - 1 - displayVal;
            if (tipY > PREVIEW_START_Y) {
              const index = (tipY * w + x) * 4;
              // Dim pixel at tip for anti-aliasing effect
              const tipBrightness = 100;
              pixels[index] = tipBrightness;
              pixels[index + 1] = tipBrightness;
              pixels[index + 2] = tipBrightness;
              pixels[index + 3] = 255;
            }
          }
        }
      }

      // Draw a subtle separator line at the top of preview area (row 39)
      for (let x = 0; x < w; x++) {
        const index = (39 * w + x) * 4;
        pixels[index] = 60;     // R - dim gray
        pixels[index + 1] = 60; // G
        pixels[index + 2] = 60; // B
        pixels[index + 3] = 255; // A
      }

      // Draw subtle division markers at 25%, 50%, 75% for reference
      // These help identify potential loop points visually
      const divisionPositions = [0.25, 0.5, 0.75];
      divisionPositions.forEach(pos => {
        const xPos = Math.floor(pos * (w - 1));
        // Draw a very subtle vertical line (1 pixel, bottom of waveform area)
        const yPos = h - 1;
        const index = (yPos * w + xPos) * 4;
        pixels[index] = 120;     // R - subtle marker
        pixels[index + 1] = 120; // G
        pixels[index + 2] = 120; // B
        pixels[index + 3] = 255; // A
      });

      // Draw playback position indicator if provided (no other markers)
      if (playbackPosition !== null && playbackPosition >= 0 && playbackPosition <= 1) {
        const indicatorX = Math.floor(playbackPosition * (w - 1));

        // Draw vertical line from top to bottom of preview area (rows 40-63)
        for (let y = PREVIEW_START_Y; y < h; y++) {
          const index = (y * w + indicatorX) * 4;
          // Invert colors - make it bright where waveform is dark, dark where bright
          const currentBrightness = pixels[index];
          const inverted = currentBrightness > 128 ? 0 : 255;

          pixels[index] = inverted;     // R
          pixels[index + 1] = inverted; // G
          pixels[index + 2] = inverted; // B
          pixels[index + 3] = 255;      // A
        }
      }

      ctx.putImageData(imageData, 0, 0);

      // Add OLED glow effect (subtle)
      ctx.shadowColor = '#ffffff';
      ctx.shadowBlur = 0.8;
      ctx.globalAlpha = 0.25;
      ctx.drawImage(canvas, 0, 0);
      ctx.shadowBlur = 0;
      ctx.globalAlpha = 1.0;

      // Optional: Add scan lines for more authentic OLED look (very subtle)
      ctx.globalAlpha = 0.03;
      ctx.fillStyle = '#000000';
      for (let y = 0; y < h; y += 2) {
        ctx.fillRect(0, y, w, 1);
      }
      ctx.globalAlpha = 1.0;
    }
  </script>
</body>
</html>
