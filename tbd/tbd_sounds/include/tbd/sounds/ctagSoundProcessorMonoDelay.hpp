#include <tbd/sound_processor.hpp>

#include <atomic>
#include "stmlib/dsp/filter.h"


namespace CTAG {
    namespace SP {
        class ctagSoundProcessorMonoDelay : public ctagSoundProcessor {
        public:
            virtual void Process(const ProcessData &) override;
            // no ctor, use Init() instead, is called from factory after successful creation
            virtual void Init(std::size_t blockSize, void *blockPtr) override;
            virtual ~ctagSoundProcessorMonoDelay();

        private:
            virtual void knowYourself() override;

            /* playing with Mutable FX Engine
            // FxEngine size must be a power of 2
            typedef mifx::FxEngine<65536, mifx::FORMAT_32_BIT> E;
            E engine;
            float *delayBuffer {nullptr};
            float delayOffset {0.0f};
            */

            float *delayBuffer;
            const uint32_t delayBufferSizeMax {88200};
            uint32_t writeIndex {0};
            float readPos {0.0f}, readPosFiltered {0.0f};
            float delayOffset {0.0f};
        	float duck {0.f};
            float delayTime_ms {0.0f};
			bool pre_sync {false};
        	float fDelayTime {0.0f};
        	float fSyncTimeStamp {0.0f};
        	int32_t timer {0}, pre_timer {0};
        	stmlib::OnePole lp, hp;

            // private attributes could go here
            // autogenerated code here
            // sectionHpp
	std::atomic<int32_t> time_ms, cv_time_ms;
	std::atomic<int32_t> sync, trig_sync;
	std::atomic<int32_t> freeze, trig_freeze;
	std::atomic<int32_t> tape_digital, trig_tape_digital;
	std::atomic<int32_t> feedback, cv_feedback;
	std::atomic<int32_t> base, cv_base;
	std::atomic<int32_t> width, cv_width;
	std::atomic<int32_t> mix, cv_mix;
	// sectionHpp
        };
    }
}
