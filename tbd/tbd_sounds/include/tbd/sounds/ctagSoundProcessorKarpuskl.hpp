#include <atomic>
#include <tbd/sound_processor.hpp>
#include "helpers/ctagSineSource.hpp"
#include "helpers/ctagFastMath.hpp"
#include "helpers/ctagADEnv.hpp"            // Needed for AD EG (Attack/Decay Enveloppe Generator)

namespace CTAG {
    namespace SP {
        class ctagSoundProcessorKarpuskl : public ctagSoundProcessor {
        public:
            virtual void Process(const ProcessData &) override;
           virtual void Init(std::size_t blockSize, void *blockPtr) override;
            virtual ~ctagSoundProcessorKarpuskl();

        private:
            virtual void knowYourself() override;
            inline int process_param_trig( const ProcessData &data, int trig_myparm, int my_parm, int prev_trig_state_id ); // rescale incoming data to bool
            inline float process_param_float( const ProcessData &data, int cv_myparm, int my_parm, float out_min = 0.f, float out_max = 1.f ); // rescale incoming data to 0.0-1.0
            inline float process_center_param_float( const ProcessData &data, int cv_myparm, int my_parm ); // rescale incoming data to -0.5-0.5
            HELPERS::ctagSineSource ringModCarrier;
            HELPERS::ctagSineSource ringModLFO;

            enum trig_states {e_KarpusklTrigger, e_SingleNotes, e_PowerChords, e_FourNoteChords, e_OctUp, e_OctDown, e_DrivePost,
                              e_ModFreqLoHi, e_LFOsquare, e_QuantizeOn, e_EnvActive, e_EnvLoop, e_Karpuskl_options_max };
            int prev_trig_state[e_Karpuskl_options_max] = {0,0,0,0,0,0,0,0,0,0,0,0};

            // --- Define the chords as used with the Stradella system, this will be used as offsets to construct our transposable note-combinations ---
            const int stradella[5][4] =  // 1) C-E-G (C major), 2) G-Eb-C (C minor), 3) Bb-E-C (C dominant 7th) 4) Eb-C-A (C diminished 7th) 5) C-E-G# (C augmented triad)
            {
              {0,4,7,12}, {0,3,7,12}, {-2,4,12,0}, {-9,0,9,12}, {0,4,8,12}
            };
            inline float noteToFreq(float incoming_note) { return  (HELPERS::fastpow2 ((incoming_note - 69.f) / 12.f) *440.f); } // MIDItoFrequency, inspired by: https://github.com/little-scale/mtof/blob/master/mtof.cpp
            inline float freqToNote(float incoming_frequency) {  return (12.f * HELPERS::fast_log2(incoming_frequency/440.f)+69.0 );  } // Also see: http://newt.phys.unsw.edu.au/jw/notes.html

            // --- Karplus Strong stuff ---
            std::vector<float> m_bufferA;      // Base note
            std::vector<float> m_bufferB;     // Fifth if powerchord (or second stradella note) is enabled
            std::vector<float> m_bufferC;     // Octave if powerchord (or third stradella note) is enabled
            std::vector<float> m_bufferD;     // Forth note if powerchord (or stradella) is enabled
            size_t m_indexA = 0;
            size_t m_indexB = 0;
            size_t m_indexC = 0;
            size_t m_indexD = 0;
            size_t m_impulse_idxA = 0;
            size_t m_impulse_idxB = 0;
            size_t m_impulse_idxC = 0;
            size_t m_impulse_idxD = 0;

            // Envelope
            HELPERS::ctagADEnv vol_env;

            // autogenerated code here
            // sectionHpp
           std::atomic<int32_t> SingleNotes, trig_SingleNotes;
           std::atomic<int32_t> PowerChords, trig_PowerChords;
           std::atomic<int32_t> FourNoteChords, trig_FourNoteChords;
           std::atomic<int32_t> OctUp, trig_OctUp;
           std::atomic<int32_t> OctDown, trig_OctDown;
           std::atomic<int32_t> KarpusklTrigger, trig_KarpusklTrigger;
           std::atomic<int32_t> KarpusklFrequ, cv_KarpusklFrequ;
           std::atomic<int32_t> Damping, cv_Damping;
           std::atomic<int32_t> Brightness, cv_Brightness;
           std::atomic<int32_t> DrivePost, trig_DrivePost;
           std::atomic<int32_t> DriveChar, cv_DriveChar;
           std::atomic<int32_t> DriveAmnt, cv_DriveAmnt;
           std::atomic<int32_t> ModMix, cv_ModMix;
           std::atomic<int32_t> ModFreq, cv_ModFreq;
           std::atomic<int32_t> ModFreqLoHi, trig_ModFreqLoHi;
           std::atomic<int32_t> LFOamnt, cv_LFOamnt;
           std::atomic<int32_t> LFOrate, cv_LFOrate;
           std::atomic<int32_t> LFOsquare, trig_LFOsquare;
           std::atomic<int32_t> MasterGain, cv_MasterGain;
           std::atomic<int32_t> EnvActive, trig_EnvActive;
           std::atomic<int32_t> VolAttack, cv_VolAttack;
           std::atomic<int32_t> VolDecay, cv_VolDecay;
           std::atomic<int32_t> EnvLoop, trig_EnvLoop;
           std::atomic<int32_t> MasterPitch, cv_MasterPitch;
           std::atomic<int32_t> QuantizeOn, trig_QuantizeOn;
	// sectionHpp
        };
    }
}

