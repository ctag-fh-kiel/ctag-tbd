from pathlib import Path
from typing import Final, Iterator

import proto_schema_parser.ast as proto
import proto_schema_parser.generator as protog

from tbd_core.buildgen import get_tbd_components_root
from tbd_core.generators import GeneratorBase, jilter
from tbd_core.reflection.reflectables import Param
from tbd_core.reflection.db import ReflectableDB, ClassPtr, flattened_properties, PropertyPtr, CppTypePtr

from .serializables import Serializables, Serializable

HEADER_NOTE = \
"""/** 
 * @warning: DO NOT EDIT!
 * 
 * This file was auto-generated by the TBD serialization library and will be overwritten!
 */
"""

class CppFilters:
    def __init__(self, render, serializables: Serializables, reflectable_db: ReflectableDB):
        self._serializables: Final[Serializables] = serializables
        self._reflectable_db: Final[ReflectableDB] = reflectable_db
        self._render = render

    @jilter
    def field_name(self, property_id: int) -> str:
        return self._reflectable_db.get_property(property_id).field_name

    @jilter
    def snake_name(self, path: str) -> str:
        return path.replace('.', '_')

    @jilter
    def flattened_properties(self, serializable: ClassPtr) -> Iterator[tuple[str, PropertyPtr]]:
        for path, prop in flattened_properties(serializable):
            yield '.'.join(path), prop

    @jilter
    def is_param(self, prop: PropertyPtr) -> bool:
        return isinstance(prop.type, Param)

    @jilter
    def param_tag(self, prop: PropertyPtr) -> str:
        return prop.type.param_type.name

    @jilter
    def proto_encoder_impl(self, serializable: Serializable) -> str:
        fields = [(prop_idx + 1, prop) for prop_idx, prop in enumerate(serializable.dto_cls.properties)]
        return self._render('templates/proto_encoder.hpp.j2', dto_type=serializable.dto_cls.full_name, fields=fields)

    @jilter
    def proto_decoder_impl(self, serializable: Serializable) -> str:
        fields = [(prop_idx + 1, prop) for prop_idx, prop in enumerate(serializable.dto_cls.properties)]
        return self._render('templates/proto_decoder.hpp.j2', dto_type=serializable.dto_cls.full_name, fields=fields)

    @jilter
    def map_anonymous(self, _type: CppTypePtr) -> str:
        if isinstance(_type, ClassPtr):
            if not _type.is_anonymous:
                return _type.typename

            for serializable in self._serializables.anonymous_class_dtos:
                if serializable.cls.ref() == _type.ref():
                    return serializable.dto_cls.typename
            raise RuntimeError(f'no DTO for anonymous class field {_type.full_name}')
        return _type.typename


class SerializableGenerator(GeneratorBase[CppFilters]):
    def __init__(self, serializables: Serializables, reflectable_db: ReflectableDB):
        super().__init__(get_tbd_components_root() / 'core' / 'tbd_serialization' / 'src',
                         CppFilters(self.render, serializables, reflectable_db))
        self._serializables: Serializables = serializables
        self._reflectable_db: ReflectableDB = reflectable_db

    def render(self, template_file: Path | str, **args) -> str:
        return super().render(template_file, reflectables=self._reflectable_db, **args)

    def write_cpp_code(self, domain: str, headers_dir: Path, srcs_dir: Path) -> None:
        cls_headers = {*[str(serializable.header.file) for serializable in self._serializables.serializable_classes],
                       *[str(serializable.header.file) for serializable in self._serializables.class_dtos]}

        dtos_header = self.render(
            'domain_dtos.hpp.j2',
            serializables=self._serializables,
            domain=domain,
            cls_headers=cls_headers)

        dtos_header_file = headers_dir / 'dtos.hpp'
        with open(dtos_header_file, 'w') as f:
            f.write(HEADER_NOTE)
            f.write(dtos_header)

        streams_header = self.render(
            'domain_serializables.hpp.j2',
            serializables=self._serializables,
            domain=domain,
            cls_headers=cls_headers
        )

        streams_header_file = headers_dir / 'serializables.hpp'
        with open(streams_header_file, 'w') as f:
            f.write(HEADER_NOTE)
            f.write(streams_header)

        streams_source = self.render(
            'domain_serializables.cpp.j2',
            serializables=self._serializables,
            domain=domain,
            cls_headers=cls_headers
        )
        streams_source_file = srcs_dir / f'serializables.cpp'
        with open(streams_source_file, 'w') as f:
            f.write(HEADER_NOTE)
            f.write(streams_source)

        messages = self.render(
            'domain_messages.hpp.j2',
            serializables=self._serializables,
            domain=domain,
            cls_headers=cls_headers,

        )
        messages_header_file = headers_dir / f'messages.hpp'
        with open(messages_header_file, 'w') as f:
            f.write(HEADER_NOTE)
            f.write(messages)

        message_encoding = self.render(
            'domain_message_encoding.hpp.j2',
            serializables=self._serializables,
            domain=domain,
            cls_headers=cls_headers,

        )
        message_encoding_header_file = headers_dir / f'message_encoding.hpp'
        with open(message_encoding_header_file, 'w') as f:
            f.write(HEADER_NOTE)
            f.write(message_encoding)

        message_decoding = self.render(
            'domain_message_decoding.hpp.j2',
            serializables=self._serializables,
            domain=domain,
            cls_headers=cls_headers,

        )
        message_decoding_header_file = headers_dir / f'message_decoding.hpp'
        with open(message_decoding_header_file, 'w') as f:
            f.write(HEADER_NOTE)
            f.write(message_decoding)


    def write_protos(self, out_file: Path) -> None:
        with out_file.open('w') as f:
            messages = protog.Generator().generate(proto.File(
                syntax='proto3',
                file_elements=list(self._serializables.messages.values()),
            ))
            f.writelines(messages)
